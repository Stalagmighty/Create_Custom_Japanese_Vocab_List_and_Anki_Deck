Index: v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># From English\r\nfrom From_English_Translate import translate_english_terms_batch\r\n\r\n# -*- coding: utf-8 -*-\r\nimport re\r\nimport csv\r\nimport hashlib\r\nfrom datetime import datetime\r\nfrom pathlib import Path\r\nimport time\r\nimport os\r\nimport threading\r\nimport tkinter as tk\r\nfrom tkinter import ttk, filedialog, messagebox, simpledialog\r\nfrom tkinter import scrolledtext\r\nimport json\r\nimport re\r\nfrom typing import Iterable, Dict, List\r\nfrom extractor import build_rows_from_text\r\n\r\n# Jisho\r\nfrom jisho_api.word import Word\r\nfrom jisho_api.sentence import Sentence\r\n\r\n# Topic service + row merge util\r\nfrom topic_service import TopicGeneratorService\r\nfrom utils import merge_rows  # def merge_rows(existing_rows, new_rows) -> tuple\r\n\r\n\r\n# Themes (optional)\r\ntry:\r\n    import ttkbootstrap as tb\r\nexcept Exception:\r\n    tb = None\r\n\r\ntry:\r\n    import sv_ttk\r\nexcept Exception:\r\n    sv_ttk = None\r\n\r\n# Google APIs (optional)\r\nfrom google.oauth2 import service_account\r\nfrom googleapiclient.discovery import build\r\nfrom googleapiclient.errors import HttpError\r\n\r\n# Anki\r\nimport genanki\r\n\r\n# OpenAI\r\nfrom openai import OpenAI\r\n\r\n# ---------------- OpenAI helpers ----------------\r\n_client = OpenAI()\r\n\r\n\r\ndef get_openai_client() -> OpenAI:\r\n    \"\"\"Lazy-load the OpenAI client (env var OPENAI_API_KEY or fallback file).\"\"\"\r\n    global _client\r\n    if _client is None:\r\n        api_key = os.getenv(\"OPENAI_API_KEY\")\r\n        if not api_key:\r\n            key_file = Path(__file__).resolve().parent / \".venv\" / \"Lib\" / \"gpt_api_secret.txt\"\r\n            api_key = key_file.read_text(encoding=\"utf-8\").strip()\r\n        _client = OpenAI(api_key=api_key)\r\n    return _client\r\n\r\ndef _extract_json(text: str) -> str:\r\n    \"\"\"\r\n    Try to pull a JSON array/object from a reply that might contain extra text\r\n    or be wrapped in ```json code fences.\r\n    \"\"\"\r\n    if not text:\r\n        return \"[]\"\r\n    # Pull fenced ```json blocks first\r\n    m = re.search(r\"```json\\s*(.+?)\\s*```\", text, flags=re.DOTALL | re.IGNORECASE)\r\n    if m:\r\n        return m.group(1).strip()\r\n    # Otherwise try to find first JSON-looking segment\r\n    start = text.find(\"[\")\r\n    if start != -1:\r\n        end = text.rfind(\"]\")\r\n        if end != -1 and end > start:\r\n            return text[start:end + 1]\r\n    start = text.find(\"{\")\r\n    if start != -1:\r\n        end = text.rfind(\"}\")\r\n        if end != -1 and end > start:\r\n            return text[start:end + 1]\r\n    return text.strip()\r\n\r\n\r\ndef _chunked(seq: Iterable, n: int):\r\n    \"\"\"Yield lists of size n from seq.\"\"\"\r\n    buf = []\r\n    for x in seq:\r\n        buf.append(x)\r\n        if len(buf) >= n:\r\n            yield buf\r\n            buf = []\r\n    if buf:\r\n        yield buf\r\n\r\n\r\ndef generate_examples_with_gpt_batch(\r\n    terms: List[str],\r\n    *,\r\n    model: str = \"gpt-4o-mini\",\r\n    batch_size: int = 40,\r\n    max_tokens_per_batch: int = 900,   # longer sentences need a bit more room\r\n    retries: int = 2,\r\n) -> Dict[str, str]:\r\n    \"\"\"\r\n    For each JP term, generate EXACTLY ONE medium-length, natural Japanese sentence\r\n    that *includes the exact term string*. Returns a dict {normalized_term: example}.\r\n    \"\"\"\r\n    if not terms:\r\n        return {}\r\n\r\n    client = get_openai_client()\r\n    result: Dict[str, str] = {}\r\n\r\n    # Tighter, shared guidance (no English, ensure term presence, longer sentence)\r\n    sys_prompt = (\r\n        \"You are a Japanese sentence generator. For each vocabulary item, \"\r\n        \"produce EXACTLY ONE natural Japanese sentence in Japanese that includes the term. \"\r\n        \"Target 60–110 Japanese characters (not words). Prefer context‑rich usage (news/academic/professional). \"\r\n        \"Return STRICT JSON only.\"\r\n    )\r\n\r\n    def _extract_text_any(resp) -> str:\r\n        \"\"\"\r\n        Works for both Responses API and Chat Completions.\r\n        Tries: .output_text → responses.output[].content[].text.value → choices[0].message.content\r\n        \"\"\"\r\n        # 1) New SDK convenience\r\n        t = getattr(resp, \"output_text\", None)\r\n        if t:\r\n            return t\r\n\r\n        # 2) Responses API canonical path\r\n        try:\r\n            out_chunks = []\r\n            for item in getattr(resp, \"output\", []) or []:\r\n                for c in getattr(item, \"content\", []) or []:\r\n                    tv = getattr(getattr(c, \"text\", None), \"value\", None)\r\n                    if tv:\r\n                        out_chunks.append(tv)\r\n            if out_chunks:\r\n                return \"\".join(out_chunks)\r\n        except Exception:\r\n            pass\r\n\r\n        # 3) Chat Completions\r\n        try:\r\n            return resp.choices[0].message.content or \"\"\r\n        except Exception:\r\n            return \"\"\r\n\r\n    def _chunked(seq: Iterable, n: int):\r\n        buf = []\r\n        for x in seq:\r\n            buf.append(x)\r\n            if len(buf) >= n:\r\n                yield buf\r\n                buf = []\r\n        if buf:\r\n            yield buf\r\n\r\n    for group in _chunked(terms, batch_size):\r\n        payload = {\r\n            \"instructions\": (\r\n                \"Return a JSON array of objects with keys 'term' and 'example'. \"\r\n                \"Rules: the example MUST include the exact JP term string and be about 60–110 JP characters.\"\r\n            ),\r\n            \"terms\": group,\r\n        }\r\n\r\n        last_err = None\r\n        raw_reply = \"\"\r\n        for attempt in range(retries + 1):\r\n            try:\r\n                if model.startswith(\"gpt-5\"):\r\n                    # Responses API (token arg name differs by SDK version).\r\n                    try:\r\n                        resp = client.responses.create(\r\n                            model=model,\r\n                            input=[\r\n                                {\"role\": \"system\", \"content\": sys_prompt},\r\n                                {\"role\": \"user\", \"content\": json.dumps(payload, ensure_ascii=False)},\r\n                            ],\r\n                            max_output_tokens=max_tokens_per_batch,\r\n                        )\r\n                    except TypeError:\r\n                        resp = client.responses.create(\r\n                            model=model,\r\n                            input=[\r\n                                {\"role\": \"system\", \"content\": sys_prompt},\r\n                                {\"role\": \"user\", \"content\": json.dumps(payload, ensure_ascii=False)},\r\n                            ],\r\n                        )\r\n                else:\r\n                    # Chat Completions\r\n                    resp = client.chat.completions.create(\r\n                        model=model,\r\n                        messages=[\r\n                            {\"role\": \"system\", \"content\": sys_prompt},\r\n                            {\"role\": \"user\", \"content\": json.dumps(payload, ensure_ascii=False)},\r\n                        ],\r\n                        max_tokens=max_tokens_per_batch,\r\n                    )\r\n\r\n                raw_reply = _extract_text_any(resp)  # <-- capture reply text\r\n                raw_json = _extract_json(raw_reply)\r\n                try:\r\n                    data = json.loads(raw_json)\r\n                except json.JSONDecodeError:\r\n                    data = []\r\n\r\n                # accept either a list or {\"items\":[...]} or a single object\r\n                if isinstance(data, dict):\r\n                    data = data.get(\"items\", data)\r\n                if not isinstance(data, list):\r\n                    data = [data]\r\n\r\n                wrote_any = False\r\n                for item in data:\r\n                    t = (item.get(\"term\") or \"\").strip()\r\n                    ex = (item.get(\"example\") or \"\").strip()\r\n                    if not t or not ex:\r\n                        continue\r\n                    # Enforce “example contains term” at client-side too.\r\n                    if t not in ex:\r\n                        continue\r\n                    result[remove_furigana(t)] = ex\r\n                    wrote_any = True\r\n                if wrote_any:\r\n                    break\r\n                else:\r\n                    # Force retry path if nothing usable parsed\r\n                    raise ValueError(\"Parsed zero usable items from batch.\")\r\n            except Exception as e:\r\n                last_err = e\r\n                time.sleep(0.4 + 0.4 * attempt)\r\n\r\n        if last_err and not any(remove_furigana(t) in result for t in group):\r\n            snippet = (raw_reply[:240] + \"…\") if raw_reply else \"\"\r\n            # Don’t raise here — just continue so other batches still run\r\n            print(f\"[GPT batch warn] group produced no items. reply snippet: {snippet}\")\r\n\r\n        time.sleep(0.08)\r\n\r\n    return result\r\n\r\nJP_RE = re.compile(r\"[\\u3040-\\u30ff\\u4e00-\\u9fff]\")\r\n\r\ndef pick_jp_term(term: str, reading: str) -> str:\r\n    term = (term or \"\").strip()\r\n    reading = (reading or \"\").strip()\r\n    # If the term has no JP chars but the reading does, use the reading\r\n    if not JP_RE.search(term) and JP_RE.search(reading):\r\n        return reading\r\n    return term\r\n\r\n\r\ndef generate_example_with_gpt(term: str, model: str = \"gpt-4o-mini\") -> str:\r\n    \"\"\"\r\n    Return a short Japanese example. Works across OpenAI SDK variants by\r\n    trying the Responses/Chat params that exist in the installed version.\r\n    \"\"\"\r\n    client = get_openai_client()\r\n    prompt = (\r\n        f\"Output ONLY one short-medium-length natural Japanese example sentence using the word '{term}'. \"\r\n        \"Do not include translations, explanations, or any other text.\"\r\n    )\r\n\r\n    def _extract_text_from_response(resp) -> str:\r\n        \"\"\"\r\n        Safely extract text content from an OpenAI Responses/Chat API response.\r\n        Works across SDK variants.\r\n        \"\"\"\r\n        # Newer SDKs expose .output_text directly\r\n        text = getattr(resp, \"output_text\", None)\r\n        if text:\r\n            return text\r\n\r\n        # Try choices[].message.content (Chat Completions style)\r\n        try:\r\n            return resp.choices[0].message.content or \"\"\r\n        except Exception:\r\n            pass\r\n\r\n        # Try newer Responses API shapes\r\n        try:\r\n            out = []\r\n            for item in getattr(resp, \"output\", []) or []:\r\n                for c in getattr(item, \"content\", []) or []:\r\n                    t = getattr(getattr(c, \"text\", None), \"value\", None)\r\n                    if t:\r\n                        out.append(t)\r\n            if out:\r\n                return \"\".join(out)\r\n        except Exception:\r\n            pass\r\n\r\n        return \"\"\r\n\r\n\r\nFURIGANA_RE = re.compile(r\"\\([^)]*\\)\")\r\ndef remove_furigana(text: str) -> str:\r\n    return FURIGANA_RE.sub(\"\", text)\r\n\r\n\r\ndef top_two_non_wiki_meanings(w_data) -> str:\r\n    picked = []\r\n    for sense in w_data.senses:\r\n        if \"Wikipedia definition\" in (sense.parts_of_speech or []):\r\n            continue\r\n        if sense.english_definitions:\r\n            picked.append(\", \".join(sense.english_definitions))\r\n        if len(picked) >= 2:\r\n            break\r\n    return \"; \".join(picked[:2]) if picked else \"\"\r\n\r\nclass CollapsiblePane(ttk.Frame):\r\n    \"\"\"A simple collapsible panel with a header toggle.\"\"\"\r\n    def __init__(self, parent, title=\"Section\", start_open=True, *args, **kwargs):\r\n        super().__init__(parent, *args, **kwargs)\r\n        self._open = bool(start_open)\r\n\r\n        # Header row\r\n        self._hdr = ttk.Frame(self)\r\n        self._hdr.pack(fill=\"x\")\r\n\r\n        self._glyph = ttk.Label(self._hdr, width=2, anchor=\"w\")\r\n        self._title = ttk.Label(self._hdr, text=title)\r\n\r\n        # Small button (optional, so focusable via keyboard)\r\n        self._btn = ttk.Button(\r\n            self._hdr, text=\"Toggle\", command=self.toggle, width=1, style=\"Tool.TButton\"\r\n        )\r\n\r\n        self._glyph.pack(side=\"left\")\r\n        self._title.pack(side=\"left\", padx=(2, 6))\r\n        self._btn.pack(side=\"right\")\r\n\r\n        self.content = ttk.Frame(self)  # container for actual content\r\n        self._sync()\r\n\r\n        # Clicking the header also toggles\r\n        self._hdr.bind(\"<Button-1>\", lambda e: self.toggle())\r\n        self._title.bind(\"<Button-1>\", lambda e: self.toggle())\r\n        self._glyph.bind(\"<Button-1>\", lambda e: self.toggle())\r\n\r\n    def toggle(self):\r\n        self._open = not self._open\r\n        self._sync()\r\n\r\n    def open(self):\r\n        self._open = True\r\n        self._sync()\r\n\r\n    def close(self):\r\n        self._open = False\r\n        self._sync()\r\n\r\n    def _sync(self):\r\n        self._glyph.config(text=\"▾\" if self._open else \"▸\")\r\n        if self._open:\r\n            self.content.pack(fill=\"both\", expand=True)\r\n        else:\r\n            self.content.forget()\r\n\r\n\r\n\r\ndef fetch_example_sentence(term: str) -> str:\r\n    try:\r\n        s_res = Sentence.request(term)\r\n        if s_res.data:\r\n            return remove_furigana(s_res.data[0].japanese)\r\n    except Exception:\r\n        pass\r\n    return \"\"\r\n\r\n\r\ndef augment_row_with_jisho(term: str, reading_hint: str | None) -> list[str]:\r\n    \"\"\"\r\n    Returns: [Term, Reading, Meaning(2 max, non-Wikipedia), Example, JLPT]\r\n    \"\"\"\r\n    w_res = Word.request(term)\r\n    if not w_res.data and reading_hint:\r\n        w_res = Word.request(reading_hint)\r\n    if not w_res.data:\r\n        return [term, reading_hint or \"\", \"\", \"\", \"\"]\r\n\r\n    w = w_res.data[0]\r\n    jp0 = w.japanese[0]\r\n    out_term = jp0.word or jp0.reading or term\r\n    out_reading = jp0.reading or (reading_hint or \"\")\r\n    meanings = top_two_non_wiki_meanings(w)\r\n    example = fetch_example_sentence(term)\r\n    jlpt = \", \".join(w.jlpt) if w.jlpt else \"\"\r\n\r\n    return [out_term, out_reading, meanings or \"\", example, jlpt]\r\n\r\n\r\ndef split_meanings(s: str):\r\n    \"\"\"Split on commas not inside ASCII parentheses; keep semicolons as-is.\"\"\"\r\n    parts, current, depth = [], [], 0\r\n    for ch in s:\r\n        if ch == '(':\r\n            depth += 1\r\n        elif ch == ')' and depth > 0:\r\n            depth -= 1\r\n        if ch == ',' and depth == 0:\r\n            part = ''.join(current).strip()\r\n            if part:\r\n                parts.append(part)\r\n            current = []\r\n        else:\r\n            current.append(ch)\r\n    last = ''.join(current).strip()\r\n    if last:\r\n        parts.append(last)\r\n    return parts\r\n\r\n# Matches entries like:  一般的（いっぱんてき） general, common, typical\r\n# …and also tolerates missing readings:  一般的  general, common\r\nTERM_BLOCK_RE = re.compile(r\"\"\"\r\n    \\s*                                  # optional leading space\r\n    (?P<term>[^\\s（）()]+)                # term (until space or bracket)\r\n    (?:\\s*[（(](?P<reading>[^）)]+)[）)])? # optional reading in JP/ASCII parens\r\n    \\s+                                  # at least one space\r\n    (?P<meaning>.+?)                     # meaning (lazy)\r\n    (?=                                  # stop when we see the next term…\r\n        \\s+[^\\s（）()]+(?:\\s*[（(][^）)]+[）)])? # …optionally with reading…\r\n        \\s+                              # …and a space\r\n      | \\s*$                             # …or end of string\r\n    )\r\n\"\"\", re.VERBOSE | re.DOTALL)\r\n\r\n\r\ndef parse_blob(text: str):\r\n    text = re.sub(r\"\\s+\", \" \", text.strip())\r\n    rows = []\r\n    for m in TERM_BLOCK_RE.finditer(text):\r\n        term = m.group(\"term\").strip()\r\n        reading = (m.group(\"reading\") or \"\").strip()\r\n        meanings_raw = m.group(\"meaning\").strip()\r\n        meanings = \", \".join(split_meanings(meanings_raw))\r\n        rows.append([term, reading, meanings, \"\", \"\"])  # Example, JLPT filled later\r\n    return rows\r\n\r\n# ---------------- Google Sheets helpers ----------------\r\nSCOPES = [\"https://www.googleapis.com/auth/spreadsheets\"]\r\n\r\n\r\ndef get_service(sa_json_path: str):\r\n    creds = service_account.Credentials.from_service_account_file(sa_json_path, scopes=SCOPES)\r\n    return build(\"sheets\", \"v4\", credentials=creds)\r\n\r\n\r\ndef ensure_sheet_exists(service, spreadsheet_id: str, title: str):\r\n    meta = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\r\n    if any(s.get(\"properties\", {}).get(\"title\") == title for s in meta.get(\"sheets\", [])):\r\n        return\r\n    service.spreadsheets().batchUpdate(\r\n        spreadsheetId=spreadsheet_id,\r\n        body={\"requests\": [{\"addSheet\": {\"properties\": {\"title\": title}}}]},\r\n    ).execute()\r\n\r\n\r\ndef write_to_sheet(service, sheet_id: str, tab: str, rows: list,\r\n                   write_headers=True, clear_body=True):\r\n    \"\"\"Write headers and rows; adapts to 3 or 5 columns based on data.\"\"\"\r\n    values_api = service.spreadsheets().values()\r\n    width = max(len(r) for r in rows) if rows else 3\r\n    if width >= 5:\r\n        headers = [\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\"]\r\n        header_range = f\"{tab}!A1:E1\"\r\n        clear_range = f\"{tab}!A2:E\"\r\n        write_start = f\"{tab}!A2\"\r\n    else:\r\n        headers = [\"Term\", \"Reading\", \"Meaning\"]\r\n        header_range = f\"{tab}!A1:C1\"\r\n        clear_range = f\"{tab}!A2:C\"\r\n        write_start = f\"{tab}!A2\"\r\n\r\n    if write_headers:\r\n        values_api.update(\r\n            spreadsheetId=sheet_id,\r\n            range=header_range,\r\n            valueInputOption=\"USER_ENTERED\",\r\n            body={\"values\": [headers]},\r\n        ).execute()\r\n    if clear_body:\r\n        values_api.clear(spreadsheetId=sheet_id, range=clear_range).execute()\r\n    if rows:\r\n        padded = [(r + [\"\", \"\", \"\"])[:len(headers)] for r in rows]\r\n        values_api.update(\r\n            spreadsheetId=sheet_id,\r\n            range=write_start,\r\n            valueInputOption=\"USER_ENTERED\",\r\n            body={\"values\": padded},\r\n        ).execute()\r\n\r\n\r\ndef read_from_sheet(service, sheet_id: str, tab: str) -> list:\r\n    \"\"\"Read Term/Reading/Meaning rows (columns A:E) from a sheet.\"\"\"\r\n    values = service.spreadsheets().values().get(\r\n        spreadsheetId=sheet_id,\r\n        range=f\"{tab}!A:E\",\r\n    ).execute().get(\"values\", [])\r\n    rows = []\r\n    for r in values[1:]:  # drop header row\r\n        padded = (r + [\"\", \"\", \"\"])[:5]\r\n        if any(c.strip() for c in padded):\r\n            rows.append(padded)\r\n    return rows\r\n\r\n\r\ndef backup_raw(service, sheet_id: str, backup_tab: str, raw_text: str):\r\n    ensure_sheet_exists(service, sheet_id, backup_tab)\r\n    ts = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\n    service.spreadsheets().values().append(\r\n        spreadsheetId=sheet_id,\r\n        range=f\"{backup_tab}!A:B\",\r\n        valueInputOption=\"RAW\",\r\n        insertDataOption=\"INSERT_ROWS\",\r\n        body={\"values\": [[ts, raw_text]]},\r\n    ).execute()\r\n\r\n\r\n# ---------------- Anki helpers ----------------\r\ndef stable_id(name: str) -> int:\r\n    \"\"\"Deterministic 32-bit int from a name (for deck/model IDs).\"\"\"\r\n    return int(hashlib.sha1(name.encode(\"utf-8\")).hexdigest()[:8], 16)\r\n\r\n\r\ndef make_anki_deck(rows: list, deck_name: str):\r\n    \"\"\"\r\n    Build a genanki.Deck from rows = [[Term, Reading, Meaning, Example, JLPT], ...].\r\n    Uses a model with 6 fields: Term, Reading, Meaning, Example, JLPT, Date.\r\n    \"\"\"\r\n    deck_id = stable_id(deck_name)\r\n    model_name = \"JP Vocab Basic v3\"\r\n    model_id = stable_id(model_name)\r\n\r\n    model = genanki.Model(\r\n        model_id=model_id,\r\n        name=model_name,\r\n        fields=[\r\n            {\"name\": \"Term\"},\r\n            {\"name\": \"Reading\"},\r\n            {\"name\": \"Meaning\"},\r\n            {\"name\": \"Example\"},\r\n            {\"name\": \"JLPT\"},\r\n            {\"name\": \"Date\"},\r\n        ],\r\n        templates=[\r\n            {\r\n                \"name\": \"Card 1\",\r\n                \"qfmt\": \"\"\"\r\n<div style=\"display:flex;align-items:center;justify-content:center;min-height:65vh;font-size:60px;font-weight:700;\">\r\n  {{Term}}\r\n</div>\r\n                \"\"\",\r\n                \"afmt\": \"\"\"\r\n<div style=\"display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:65vh;padding:10px;color:#fff !important;\">\r\n  <div style=\"font-size:60px;font-weight:700;\">{{Term}}</div>\r\n  <div style=\"font-size:34px;margin-top:10px;\">{{Reading}}</div>\r\n  <hr style=\"width:100%;border:none;border-top:1px solid #aaa;margin:16px 0;\">\r\n  <div style=\"font-size:28px;line-height:1.4;text-align:center;max-width:900px;\">\r\n    {{Meaning}}\r\n  </div>\r\n  {{#Example}}\r\n  <div style=\"margin-top:16px;font-size:24px;line-height:1.4;text-align:center;max-width:900px;\">\r\n    <b>Example:</b> {{Example}}\r\n  </div>\r\n  {{/Example}}\r\n  {{#JLPT}}\r\n  <div style=\"margin-top:12px;font-size:18px;color:#ddd;\">\r\n    JLPT: {{JLPT}}\r\n  </div>\r\n  {{/JLPT}}\r\n  <div style=\"font-size:14px;color:#eaeaea;margin-top:16px;\">\r\n    Added: {{Date}}\r\n  </div>\r\n</div>\r\n\"\"\"\r\n            }\r\n        ],\r\n    )\r\n\r\n    deck = genanki.Deck(deck_id=deck_id, name=deck_name)\r\n    today = datetime.today().strftime(\"%Y-%m-%d\")\r\n\r\n    for row in rows:\r\n        term, reading, meaning, example, jlpt = (row + [\"\", \"\", \"\"])[:5]\r\n        guid = genanki.guid_for(f\"v3|{term}|{reading}\")  # version tag to avoid collision\r\n        note = genanki.Note(\r\n            model=model,\r\n            fields=[term, reading, meaning, example, jlpt, today],\r\n            guid=guid,\r\n        )\r\n        deck.add_note(note)\r\n\r\n    return deck\r\n\r\n\r\n# ---------------- GUI ----------------\r\nclass App(tk.Tk):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.title(\"Japanese Vocab Parser → CSV / Google Sheets / Anki\")\r\n        self.geometry(\"1000x680\")\r\n\r\n        self._enrich_running = False\r\n\r\n        # --- Top controls bar ---\r\n        controls_frame = ttk.Frame(self)\r\n        controls_frame.pack(fill=\"x\", padx=10, pady=6)\r\n\r\n        # Topic service (reused)\r\n        self.topic_service = TopicGeneratorService(augment_row_with_jisho=augment_row_with_jisho)\r\n\r\n        # Theming\r\n        if tb:\r\n            tb.Style(\"darkly\")\r\n        elif sv_ttk:\r\n            sv_ttk.set_theme(\"dark\")\r\n        else:\r\n            ttk.Style().theme_use(\"clam\")\r\n\r\n        self.option_add(\"*Font\", (\"Segoe UI\", 10))\r\n        style = ttk.Style()\r\n        style.configure(\"TButton\", padding=(10, 6))\r\n        style.configure(\"TRadiobutton\", padding=(6, 2))\r\n        style.configure(\"TCheckbutton\", padding=(6, 2))\r\n        style.configure(\"Treeview.Heading\", font=(\"Segoe UI Semibold\", 10))\r\n        style.configure(\"Treeview\", rowheight=26)\r\n        style.configure(\"Tool.TButton\", padding=(12, 6))\r\n\r\n        # Top bar widgets\r\n        self.topic_var = tk.StringVar()\r\n        self.topic_count_var = tk.IntVar(value=30)\r\n        self.gpt_only_var = tk.BooleanVar(value=False)\r\n        self.append_var = tk.BooleanVar(value=True)\r\n\r\n        ttk.Label(controls_frame, text=\"Topic:\").grid(row=0, column=0, padx=4, pady=4, sticky=\"w\")\r\n        ttk.Entry(controls_frame, textvariable=self.topic_var, width=24).grid(\r\n            row=0, column=1, padx=4, pady=4, sticky=\"we\"\r\n        )\r\n        ttk.Label(controls_frame, text=\"Items:\").grid(row=0, column=2, padx=4, pady=4, sticky=\"e\")\r\n        ttk.Spinbox(controls_frame, from_=5, to=200, textvariable=self.topic_count_var, width=6).grid(\r\n            row=0, column=3, padx=4, pady=4\r\n        )\r\n        ttk.Checkbutton(controls_frame, text=\"GPT only\", variable=self.gpt_only_var).grid(row=0, column=4, padx=6)\r\n        ttk.Button(controls_frame, text=\"Generate from Topic\", command=self.on_generate_from_topic).grid(\r\n            row=0, column=5, padx=6\r\n        )\r\n        ttk.Checkbutton(controls_frame, text=\"Append\", variable=self.append_var).grid(row=0, column=6, padx=6)\r\n\r\n        # State\r\n        self.rows: list[list[str]] = []\r\n        self.only_fill_empty_var = tk.BooleanVar(value=True)\r\n\r\n        # --- Inputs + buttons area ---\r\n        top = ttk.Frame(self, padding=8)\r\n        top.pack(side=tk.TOP, fill=tk.X)\r\n\r\n        # Raw input\r\n        ttk.Label(top, text=\"Paste raw vocab text:\").grid(row=0, column=0, sticky=\"w\")\r\n        self.text = tk.Text(top, height=8, wrap=\"word\")\r\n        self.text.grid(row=1, column=0, columnspan=6, sticky=\"nsew\", pady=(4, 8))\r\n        text_scroll = ttk.Scrollbar(top, orient=\"vertical\", command=self.text.yview)\r\n        text_scroll.grid(row=1, column=6, sticky=\"ns\")\r\n        self.text.configure(yscrollcommand=text_scroll.set)\r\n\r\n        # Google config\r\n        ttk.Label(top, text=\"Service Account JSON:\").grid(row=2, column=0, sticky=\"w\", pady=(2, 0))\r\n        self.sa_entry = ttk.Entry(top, width=60)\r\n        self.sa_entry.grid(row=2, column=1, columnspan=4, sticky=\"we\", padx=(4, 4))\r\n        default_sa_path = r\"C:/Users/Tom/OneDrive/Coding Projects/Japanese_App_BackUp_Words/.venv/Scripts/python-fs-automation-3181504752ca.json\"\r\n        self.sa_entry.insert(0, default_sa_path)\r\n        ttk.Button(top, text=\"Browse…\", command=self.browse_sa).grid(row=2, column=5, sticky=\"w\")\r\n\r\n        ttk.Label(top, text=\"Sheet ID:\").grid(row=3, column=0, sticky=\"w\", pady=(2, 0))\r\n        self.sheet_entry = ttk.Entry(top, width=60)\r\n        self.sheet_entry.grid(row=3, column=1, columnspan=4, sticky=\"we\", padx=(4, 4))\r\n\r\n        ttk.Label(top, text=\"Tab name:\").grid(row=4, column=0, sticky=\"w\", pady=(2, 0))\r\n        self.tab_entry = ttk.Entry(top, width=20)\r\n        self.tab_entry.insert(0, \"List_Test_Data\")\r\n        self.tab_entry.grid(row=4, column=1, sticky=\"w\")\r\n\r\n        ttk.Label(top, text=\"Backup tab:\").grid(row=4, column=2, sticky=\"e\")\r\n        self.backup_tab_entry = ttk.Entry(top, width=20)\r\n        self.backup_tab_entry.insert(0, \"Raw_Backup\")\r\n        self.backup_tab_entry.grid(row=4, column=3, sticky=\"w\", padx=(4, 4))\r\n        self.backup_var = tk.BooleanVar(value=True)\r\n        ttk.Checkbutton(top, text=\"Backup raw input\", variable=self.backup_var).grid(row=4, column=4, sticky=\"w\")\r\n\r\n        ttk.Checkbutton(top, text=\"Only fill empty Example\", variable=self.only_fill_empty_var).grid(\r\n            row=4, column=5, sticky=\"w\"\r\n        )\r\n\r\n        # Action buttons row\r\n        btns = ttk.Frame(top)\r\n        btns.grid(row=5, column=0, columnspan=6, sticky=\"w\", pady=(10, 4))\r\n        self._buttons: list[ttk.Button] = []\r\n\r\n        def _add_btn(text, cmd):\r\n            b = ttk.Button(btns, text=text, command=cmd, style=\"Tool.TButton\")\r\n            b.pack(side=tk.LEFT, padx=6)\r\n            self._buttons.append(b)\r\n\r\n        _add_btn(\"Parse\uD83E\uDDFE\", self.on_parse)\r\n        _add_btn(\"Save CSV\uD83D\uDCBE\", self.on_save_csv)\r\n        _add_btn(\"Read from Google Sheet⬇\uFE0F\", self.on_read_sheet)\r\n        _add_btn(\"Write to Google Sheet⬆\uFE0F\", self.on_write_sheet)\r\n        _add_btn(\"Make Anki Deck\uD83C\uDCCF\", self.on_make_anki)\r\n        _add_btn(\"Augment Examples✨\", self.on_augment_examples)\r\n        _add_btn(\"From English → Rows\", self.from_english_rows)\r\n        _add_btn(\"Extract from Text\uD83E\uDDE0\", self.on_extract_from_text)\r\n        _add_btn(\"Clear\uD83E\uDDF9\", self.on_clear)\r\n\r\n        # Source mode\r\n        self.source_mode = tk.IntVar(value=2)  # 0=Jisho only, 1=GPT only, 2=Jisho→GPT\r\n        ttk.Separator(top, orient=\"horizontal\").grid(row=6, column=0, columnspan=6, sticky=\"we\", pady=(8, 8))\r\n        mode_row = ttk.LabelFrame(top, text=\"Example source\")\r\n        mode_row.grid(row=7, column=0, columnspan=6, sticky=\"we\")\r\n        mode_row.columnconfigure(3, weight=1)\r\n        ttk.Radiobutton(mode_row, text=\"Jisho only\", variable=self.source_mode, value=0).grid(\r\n            row=0, column=0, padx=8, pady=6, sticky=\"w\"\r\n        )\r\n        ttk.Radiobutton(mode_row, text=\"GPT only\", variable=self.source_mode, value=1).grid(\r\n            row=0, column=1, padx=8, pady=6, sticky=\"w\"\r\n        )\r\n        ttk.Radiobutton(mode_row, text=\"Jisho → GPT\", variable=self.source_mode, value=2).grid(\r\n            row=0, column=2, padx=8, pady=6, sticky=\"w\"\r\n        )\r\n\r\n        # Status\r\n        self.status = ttk.Label(top, text=\"Ready\")\r\n        self.status.grid(row=8, column=0, columnspan=6, sticky=\"w\", pady=(8, 0))\r\n\r\n        # --- Progress bars ---\r\n        self.gen_pb = ttk.Progressbar(top, orient=\"horizontal\", mode=\"determinate\", maximum=100, length=240)\r\n        self.gen_pb.grid(row=8, column=4, sticky=\"e\", padx=(8, 0))\r\n        ttk.Label(top, text=\"Gen\").grid(row=8, column=3, sticky=\"e\", padx=(16, 0))\r\n\r\n        self.enrich_pb = ttk.Progressbar(top, orient=\"horizontal\", mode=\"determinate\", maximum=100, length=240)\r\n        self.enrich_pb.grid(row=8, column=5, sticky=\"e\")\r\n        ttk.Label(top, text=\"Enrich\").grid(row=8, column=5, sticky=\"w\", padx=(0, 8))\r\n\r\n        # --- Activity log (collapsible) ---\r\n        self.log_pane = CollapsiblePane(self, title=\"Activity log\", start_open=False)\r\n        self.log_pane.pack(side=tk.TOP, fill=tk.BOTH, expand=False, padx=8, pady=(0, 8))\r\n\r\n        self.log_text = scrolledtext.ScrolledText(self.log_pane.content, height=8, wrap=\"word\")\r\n        self.log_text.pack(fill=tk.BOTH, expand=True)\r\n        self.log_text.configure(state=\"disabled\")\r\n\r\n        # optional: hotkey to toggle the pane\r\n        self.bind(\"<Control-Shift-L>\", lambda e: self.log_pane.toggle())\r\n\r\n        # for safe shutdown / avoiding bgerror\r\n        self._closing = False\r\n        self.protocol(\"WM_DELETE_WINDOW\", self._on_close)\r\n\r\n        # Make text grow\r\n        top.grid_columnconfigure(1, weight=1)\r\n        top.grid_rowconfigure(1, weight=1)\r\n\r\n        # --- Table preview ---\r\n        table_frame = ttk.Frame(self, padding=8)\r\n        table_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)\r\n        columns = (\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\")\r\n        self.tree = ttk.Treeview(table_frame, columns=columns, show=\"headings\", height=14)\r\n        for col in columns:\r\n            self.tree.heading(col, text=col)\r\n        self.tree.column(\"Term\", width=150, anchor=\"w\", stretch=False)\r\n        self.tree.column(\"Reading\", width=140, anchor=\"w\", stretch=False)\r\n        self.tree.column(\"Meaning\", width=260, anchor=\"w\", stretch=True)\r\n        self.tree.column(\"Example\", width=360, anchor=\"w\", stretch=True)\r\n        self.tree.column(\"JLPT\", width=80, anchor=\"w\", stretch=False)\r\n        # self.tree.tag_configure(\"oddrow\", background=\"#f6f7fb\")\r\n        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\r\n        scroll_y = ttk.Scrollbar(table_frame, orient=\"vertical\", command=self.tree.yview)\r\n        self.tree.configure(yscrollcommand=scroll_y.set)\r\n        scroll_y.pack(side=tk.RIGHT, fill=tk.Y)\r\n\r\n    # ---------- utilities ----------\r\n    def _set_buttons_enabled(self, enabled: bool):\r\n        state = \"normal\" if enabled else \"disabled\"\r\n        for b in getattr(self, \"_buttons\", []):\r\n            try:\r\n                b.configure(state=state)\r\n            except Exception:\r\n                pass\r\n\r\n    def _pulse(self, text: str):\r\n        try:\r\n            self.after(0, self.status.config, {\"text\": text})\r\n        except Exception:\r\n            pass\r\n        print(text, flush=True)\r\n\r\n    # ---------- UI handlers ----------\r\n    def browse_sa(self):\r\n        path = filedialog.askopenfilename(\r\n            title=\"Select Service Account JSON\",\r\n            filetypes=[(\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")],\r\n        )\r\n        if path:\r\n            self.sa_entry.delete(0, tk.END)\r\n            self.sa_entry.insert(0, path)\r\n\r\n\r\n        def toggle(self):\r\n            self._open = not self._open\r\n            self._sync()\r\n\r\n        def open(self):\r\n            self._open = True\r\n            self._sync()\r\n\r\n        def close(self):\r\n            self._open = False\r\n            self._sync()\r\n\r\n        def _sync(self):\r\n            self._glyph.config(text=\"▾\" if self._open else \"▸\")\r\n            if self._open:\r\n                self.content.pack(fill=\"both\", expand=True)\r\n            else:\r\n                self.content.forget()\r\n\r\n    def on_parse(self):\r\n        raw = self.text.get(\"1.0\", \"end-1c\")\r\n        self.rows = parse_blob(raw)\r\n        self.refresh_table()\r\n        self.status.config(text=f\"Parsed {len(self.rows)} rows.\")\r\n        if not self.rows:\r\n            messagebox.showwarning(\r\n                \"No entries parsed\",\r\n                \"I couldn't find any entries. Format should look like: 語（ご） meanings ...\",\r\n            )\r\n\r\n    def refresh_table(self):\r\n        self.tree.delete(*self.tree.get_children())\r\n        for idx, r in enumerate(self.rows):\r\n            row5 = (r + [\"\", \"\", \"\", \"\", \"\"])[:5]  # Term, Reading, Meaning, Example, JLPT\r\n            tags = (\"oddrow\",) if (idx % 2) else ()\r\n            self.tree.insert(\"\", \"end\", values=row5, tags=tags)\r\n\r\n    def on_clear(self):\r\n        self.text.delete(\"1.0\", \"end\")\r\n        self.rows = []\r\n        self.tree.delete(*self.tree.get_children())\r\n        self.status.config(text=\"Cleared input and table.\")\r\n        try:\r\n            self.text.focus_set()\r\n        except Exception:\r\n            pass\r\n\r\n    def on_save_csv(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to save\", \"Parse first, then save.\")\r\n            return\r\n        path = filedialog.asksaveasfilename(\r\n            title=\"Save CSV\",\r\n            defaultextension=\".csv\",\r\n            filetypes=[(\"CSV\", \"*.csv\"), (\"All files\", \"*.*\")],\r\n        )\r\n        if not path:\r\n            return\r\n        try:\r\n            width = max(len(r) for r in self.rows) if self.rows else 3\r\n            headers = (\r\n                [\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\"]\r\n                if width >= 5\r\n                else [\"Term\", \"Reading\", \"Meaning\"]\r\n            )\r\n            with open(path, \"w\", encoding=\"utf-8-sig\", newline=\"\") as f:\r\n                writer = csv.writer(f)\r\n                writer.writerow(headers)\r\n                for r in self.rows:\r\n                    row = (r + [\"\", \"\", \"\"])[:len(headers)]\r\n                    writer.writerow(row)\r\n            self.status.config(text=f\"Saved CSV: {path}\")\r\n        except Exception as e:\r\n            messagebox.showerror(\"Save error\", str(e))\r\n\r\n    def on_read_sheet(self):\r\n        sa = self.sa_entry.get().strip()\r\n        sheet_id = self.sheet_entry.get().strip()\r\n        tab = self.tab_entry.get().strip()\r\n        if not (sa and sheet_id and tab):\r\n            messagebox.showwarning(\r\n                \"Missing details\", \"Please provide Service Account JSON path, Sheet ID, and Tab name.\"\r\n            )\r\n            return\r\n        try:\r\n            svc = get_service(sa)\r\n            self.rows = read_from_sheet(svc, sheet_id, tab)\r\n            self.refresh_table()\r\n            self.status.config(text=f\"Read {len(self.rows)} rows from {tab}.\")\r\n            messagebox.showinfo(\"Done\", f\"Read {len(self.rows)} rows from '{tab}'.\")\r\n        except HttpError as he:\r\n            messagebox.showerror(\"Google API error\", str(he))\r\n        except Exception as e:\r\n            messagebox.showerror(\"Error\", str(e))\r\n\r\n    def on_write_sheet(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to write\", \"Parse first, then write to Google Sheet.\")\r\n            return\r\n        sa = self.sa_entry.get().strip()\r\n        sheet_id = self.sheet_entry.get().strip()\r\n        tab = self.tab_entry.get().strip()\r\n        backup_tab = self.backup_tab_entry.get().strip()\r\n        do_backup = self.backup_var.get()\r\n        if not (sa and sheet_id and tab):\r\n            messagebox.showwarning(\r\n                \"Missing details\", \"Please provide Service Account JSON path, Sheet ID, and Tab name.\"\r\n            )\r\n            return\r\n        try:\r\n            svc = get_service(sa)\r\n            if do_backup:\r\n                raw = self.text.get(\"1.0\", \"end-1c\").strip()\r\n                if raw:\r\n                    backup_raw(svc, sheet_id, backup_tab, raw)\r\n            write_to_sheet(svc, sheet_id, tab, self.rows, write_headers=True, clear_body=True)\r\n            self.status.config(text=f\"Wrote {len(self.rows)} rows to {tab} in the Google Sheet.\")\r\n            messagebox.showinfo(\"Done\", f\"Wrote {len(self.rows)} rows to '{tab}'.\")\r\n        except HttpError as he:\r\n            messagebox.showerror(\"Google API error\", str(he))\r\n        except Exception as e:\r\n            messagebox.showerror(\"Error\", str(e))\r\n\r\n    def on_augment_examples(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to augment\", \"Parse or load rows first, then choose a source mode.\")\r\n            return\r\n        mode = int(self.source_mode.get())  # 0=Jisho only, 1=GPT only, 2=Jisho→GPT\r\n        self._set_buttons_enabled(False)\r\n        self.status.config(text=\"Starting augmentation…\")\r\n        threading.Thread(target=self._enrich_worker, args=(mode,), daemon=True).start()\r\n\r\n    def _enrich_worker(self, mode: int):\r\n        \"\"\"Run Jisho + GPT enrichment over self.rows with progress bars.\"\"\"\r\n\r\n        if self._enrich_running:\r\n            self._safe_after(0, self.log, \"Enrichment already running; request ignored.\", False)\r\n            self._safe_after(0, self._set_buttons_enabled, True)\r\n            return\r\n        self._enrich_running = True\r\n\r\n        def ensure_width5(row):\r\n            row = list(row)\r\n            if len(row) < 5:\r\n                row.extend([\"\"] * (5 - len(row)))\r\n            return row\r\n\r\n        def has_text(s: str | None) -> bool:\r\n            return bool((s or \"\").strip())\r\n\r\n        try:\r\n            n = len(self.rows)\r\n            jisho_updates = 0\r\n            gpt_updates = 0\r\n\r\n            # -------- PASS 1: Jisho --------\r\n            if mode in (0, 2):\r\n                self._safe_after(0, self.log, f\"Jisho pass starting… ({n} rows)\")\r\n                for i, row in enumerate(self.rows):\r\n                    if self._closing:\r\n                        break\r\n                    row = ensure_width5(row)\r\n                    term = (row[0] if row else \"\").strip()\r\n                    reading_hint = (row[1] if len(row) > 1 else \"\").strip() or None\r\n                    try:\r\n                        new_row = augment_row_with_jisho(term, reading_hint)\r\n                        new_row = ensure_width5(new_row)\r\n                    except Exception as e:\r\n                        self._safe_after(0, self.log, f\"[JISHO] {term!r}: {e}\", False)\r\n                        new_row = row\r\n\r\n                    if self.only_fill_empty_var.get() and has_text(row[3]) and not has_text(new_row[3]):\r\n                        new_row[3] = row[3]\r\n\r\n                    changed = (new_row != row)\r\n                    self.rows[i] = new_row\r\n                    if changed:\r\n                        jisho_updates += 1\r\n\r\n                    if i % 2 == 0 or i == n - 1:\r\n                        self._safe_after(0, self._set_pb, self.enrich_pb, i + 1, n)\r\n                        self._safe_after(0, self.log,\r\n                                         f\"Jisho {i + 1}/{n} (upd {jisho_updates})\",\r\n                                         False)\r\n\r\n                self._safe_after(0, self.refresh_table)  # <— refresh table after Jisho pass\r\n\r\n            # Reset bar before GPT pass\r\n            self._safe_after(0, self._set_pb, self.enrich_pb, 0, 1)\r\n\r\n            # -------- PASS 2: GPT (BATCHED) --------\r\n            if mode in (1, 2) and not self._closing:\r\n                need_idxs: List[int] = []\r\n                need_terms: List[str] = []\r\n\r\n                for i, row in enumerate(self.rows):\r\n                    row = ensure_width5(row)\r\n                    term = (row[0] if row else \"\").strip()\r\n                    reading = (row[1] if len(row) > 1 else \"\").strip()\r\n                    meaning = (row[2] if len(row) > 2 else \"\").strip()\r\n\r\n                    if not term and not reading and not meaning:\r\n                        continue\r\n\r\n                    # If Term is English (no JP chars), use Meaning; else use Term.\r\n                    # If Meaning is empty, fall back to Reading if it's JP.\r\n                    if term and not JP_RE.search(term):\r\n                        term_for_gen = meaning or (reading if JP_RE.search(reading) else term)\r\n                    else:\r\n                        term_for_gen = term or (reading if JP_RE.search(reading) else meaning)\r\n\r\n                    if mode == 1:\r\n                        if self.only_fill_empty_var.get() and (row[3] or \"\").strip():\r\n                            continue\r\n                        need_idxs.append(i)\r\n                        need_terms.append(term_for_gen)\r\n                    else:  # mode == 2 (Jisho → GPT): only if Example empty\r\n                        if not (row[3] or \"\").strip():\r\n                            need_idxs.append(i)\r\n                            need_terms.append(term_for_gen)\r\n\r\n                need_total = len(need_idxs)\r\n                done = 0\r\n                self._safe_after(0, self.log, f\"GPT pass starting… ({need_total} rows need examples)\")\r\n                self._safe_after(0, self._set_pb, self.enrich_pb, 0, max(1, need_total))\r\n\r\n                if need_total > 0 and not self._closing:\r\n                    try:\r\n                        term_to_example = generate_examples_with_gpt_batch(\r\n                            need_terms,\r\n                            model=\"gpt-4o-mini\",\r\n                            batch_size=20,\r\n                            max_tokens_per_batch=2000,  # ✅ correct kwarg\r\n                        )\r\n\r\n                    except Exception as e:\r\n                        self._safe_after(0, self.log, f\"[GPT batch] failed: {e}\", False)\r\n                        term_to_example = {}\r\n\r\n                    # Build ordered fallback to handle term key drift\r\n                    ordered_fallback = []\r\n                    for t in need_terms:\r\n                        ordered_fallback.append(\r\n                            term_to_example.get(remove_furigana(t)) or term_to_example.get(t) or \"\"\r\n                        )\r\n\r\n                    if need_total > 0 and not self._closing and not term_to_example:\r\n                        self._safe_after(0, self.log, \"[GPT batch] returned no usable items.\", False)\r\n\r\n                    # Write back\r\n                    for j, (idx, term) in enumerate(zip(need_idxs, need_terms)):\r\n                        if self._closing:\r\n                            break\r\n                        ex = (term_to_example.get(remove_furigana(term))\r\n                              or term_to_example.get(term)\r\n                              or ordered_fallback[j] or \"\").strip()\r\n                        if ex:\r\n                            row = ensure_width5(self.rows[idx])\r\n                            row[3] = ex\r\n                            self.rows[idx] = row\r\n                            gpt_updates += 1\r\n                            preview = (ex[:18] + \"…\") if len(ex) > 20 else ex\r\n                            self._safe_after(0, self.log, f\"GPT wrote: {preview}\", False)\r\n                        done += 1\r\n                        self._safe_after(0, self._set_pb, self.enrich_pb, done, max(1, need_total))\r\n                        if done % 20 == 0 or done == need_total:\r\n                            self._safe_after(0, self.refresh_table)\r\n\r\n                    # final refresh\r\n                    self._safe_after(0, self.refresh_table)\r\n\r\n\r\n        finally:\r\n            self._enrich_running = False\r\n            self._safe_after(0, self._set_buttons_enabled, True)\r\n\r\n    def _on_close(self):\r\n        \"\"\"Mark as closing and destroy safely (prevents bgerror after window closes).\"\"\"\r\n        self._closing = True\r\n        try:\r\n            self.destroy()\r\n        except Exception:\r\n            pass\r\n\r\n    def _safe_after(self, delay_ms, func, *args, **kwargs):\r\n        \"\"\"Only schedule UI updates if window still exists.\"\"\"\r\n        if not self._closing and self.winfo_exists():\r\n            self.after(delay_ms, func, *args, **kwargs)\r\n\r\n    def log(self, msg: str, status: bool = True):\r\n        \"\"\"Append a timestamped line to the log and print to console.\"\"\"\r\n        ts = datetime.now().strftime(\"%H:%M:%S\")\r\n        line = f\"[{ts}] {msg}\\n\"\r\n        print(line.strip(), flush=True)\r\n        try:\r\n            self.log_text.configure(state=\"normal\")\r\n            self.log_text.insert(\"end\", line)\r\n            self.log_text.see(\"end\")\r\n            self.log_text.configure(state=\"disabled\")\r\n        except Exception:\r\n            pass\r\n        if status:\r\n            try:\r\n                self.status.config(text=msg)\r\n            except Exception:\r\n                pass\r\n\r\n    def _set_pb(self, bar: ttk.Progressbar, current: int, total: int):\r\n        \"\"\"Update a progressbar deterministically (0–100).\"\"\"\r\n        try:\r\n            val = int(100 * (current / max(1, total)))\r\n            bar[\"value\"] = max(0, min(100, val))\r\n            bar.update_idletasks()\r\n        except Exception:\r\n            pass\r\n\r\n    def _reset_progress(self):\r\n        for pb in (self.gen_pb, self.enrich_pb):\r\n            try:\r\n                pb[\"value\"] = 0\r\n                pb.update_idletasks()\r\n            except Exception:\r\n                pass\r\n\r\n    def on_extract_from_text(self):\r\n        raw = self.text.get(\"1.0\", \"end-1c\").strip()\r\n        if not raw:\r\n            messagebox.showinfo(\"No text\", \"Paste a Japanese article or any unstructured text first.\")\r\n            return\r\n\r\n        try:\r\n            candidates_rows = build_rows_from_text(\r\n                raw,\r\n                top_k=int(self.topic_count_var.get() or 80),\r\n                min_freq=1,  # adjust if articles are long/short\r\n                allow_phrases=True,\r\n                max_ngram_len=3,\r\n            )\r\n        except Exception as e:\r\n            messagebox.showerror(\"Extract error\", str(e))\r\n            return\r\n\r\n        if not candidates_rows:\r\n            messagebox.showinfo(\"Nothing found\", \"I couldn't extract useful terms.\")\r\n            return\r\n\r\n        # merge with existing rows (you already have merge_rows)\r\n        try:\r\n            merged, added, updated, *_ = merge_rows(self.rows or [], candidates_rows)\r\n        except ValueError:\r\n            merged, added, updated = merge_rows(self.rows or [], candidates_rows)\r\n\r\n        self.rows = merged\r\n        self.refresh_table()\r\n        self.log(f\"Extracted {len(candidates_rows)} items; appended {added}, updated {updated}.\")\r\n\r\n        # optionally kick off Jisho → GPT enrichment\r\n        # self.start_enrichment_worker()\r\n\r\n    # ----- Self-Service Topic Generator (unique & fills to requested count) -----\r\n    def on_generate_from_topic(self):\r\n        topic = (self.topic_var.get() or \"\").strip()\r\n        if not topic:\r\n            messagebox.showinfo(\"Topic required\", \"Type a topic (e.g., 空港 / airport).\")\r\n            return\r\n\r\n        count = max(5, int(self.topic_count_var.get() or 30))\r\n        gpt_only = bool(self.gpt_only_var.get())\r\n\r\n        self._set_buttons_enabled(False)\r\n        self._reset_progress()\r\n        self.log(f\"Generating {count} unique items for: {topic} …\")\r\n\r\n        def run():\r\n            try:\r\n                existing_keys = set()\r\n                for r in (self.rows or []):\r\n                    term = (r[0] if len(r) > 0 else \"\").strip()\r\n                    reading = (r[1] if len(r) > 1 else \"\").strip()\r\n                    if term:\r\n                        existing_keys.add((term, reading))\r\n\r\n                target = count\r\n                new_rows: list[list[str]] = []\r\n                batch_size = max(10, min(50, target * 2))\r\n                rounds = 0\r\n                no_progress_rounds = 0\r\n                MAX_ROUNDS = 30\r\n\r\n                while len(new_rows) < target and not self._closing:\r\n                    rounds += 1\r\n                    needed = target - len(new_rows)\r\n                    ask_for = max(needed, batch_size)\r\n                    self._safe_after(0, self.log, f\"[Gen {rounds}] Asking service for ~{ask_for} (need {needed})…\")\r\n\r\n                    batch = self.topic_service.generate_rows(\r\n                        topic=topic,\r\n                        count=ask_for,\r\n                        gpt_only=gpt_only,\r\n                        existing_keys=existing_keys\r\n                    )\r\n\r\n                    kept_before = len(new_rows)\r\n                    for row in (batch or []):\r\n                        term = (row[0] if len(row) > 0 else \"\").strip()\r\n                        reading = (row[1] if len(row) > 1 else \"\").strip()\r\n                        if not term:\r\n                            continue\r\n                        key = (term, reading)\r\n                        if key in existing_keys:\r\n                            continue\r\n                        if any(((r[0] if len(r) > 0 else \"\").strip(),\r\n                                (r[1] if len(r) > 1 else \"\").strip()) == key for r in new_rows):\r\n                            continue\r\n                        new_rows.append(row)\r\n                        existing_keys.add(key)\r\n                        if len(new_rows) >= target:\r\n                            break\r\n\r\n                    gained = len(new_rows) - kept_before\r\n                    self._safe_after(0, self._set_pb, self.gen_pb, len(new_rows), target)\r\n                    self._safe_after(0, self.log,\r\n                                     f\"[Gen {rounds}] Got {len(batch)}; kept {gained}; total {len(new_rows)}/{target}\",\r\n                                     False)\r\n\r\n                    no_progress_rounds = no_progress_rounds + 1 if gained == 0 else 0\r\n                    if no_progress_rounds >= 5:\r\n                        raise RuntimeError(\"No progress after several rounds. The generator may be stuck.\")\r\n                    if rounds >= MAX_ROUNDS:\r\n                        raise RuntimeError(\"Too many rounds while trying to reach requested count.\")\r\n\r\n                # merge/replace\r\n                if self.append_var.get():\r\n                    try:\r\n                        merged, added, updated, *_ = merge_rows(self.rows or [], new_rows)\r\n                    except ValueError:\r\n                        merged, added, updated = merge_rows(self.rows or [], new_rows)\r\n                    self.rows = merged\r\n                    msg = f\"Appended {added} new, updated {updated}. Total: {len(self.rows)}\"\r\n                else:\r\n                    self.rows = new_rows\r\n                    msg = f\"Replaced with {len(new_rows)} rows.\"\r\n\r\n                self._safe_after(0, self.refresh_table)\r\n                self._safe_after(0, self.log, msg)\r\n                self._safe_after(0, self.start_enrichment_worker)\r\n\r\n            except Exception as e:\r\n                self._safe_after(0, messagebox.showerror, \"Topic generation failed\", str(e))\r\n                self._safe_after(0, self.log, \"Topic generation failed.\")\r\n            finally:\r\n                self._safe_after(0, self._set_buttons_enabled, True)\r\n\r\n        threading.Thread(target=run, daemon=True).start()\r\n\r\n    def start_enrichment_worker(self):\r\n        try:\r\n            mode_value = int(self.source_mode.get())\r\n        except Exception:\r\n            mode_value = 2\r\n        self.status.config(text=\"Starting enrichment…\")\r\n        threading.Thread(target=self._enrich_worker, args=(mode_value,), daemon=True).start()\r\n\r\n    def from_english_rows(self):\r\n        \"\"\"Translate English words/phrases in the big text box into JP rows (batched).\"\"\"\r\n        raw = (self.text.get(\"1.0\", \"end-1c\") or \"\").strip()\r\n        if not raw:\r\n            messagebox.showinfo(\"Nothing to translate\", \"Paste English words/phrases first.\")\r\n            return\r\n\r\n        # Split by newlines, commas, semicolons, tabs, or pipes\r\n        import re\r\n        parts = [p.strip() for p in re.split(r\"[,\\n;\\t|]+\", raw) if p.strip()]\r\n\r\n        # Keep items that look English (contain Latin letters)\r\n        english_terms = [p for p in parts if re.search(r\"[A-Za-z]\", p)]\r\n        if not english_terms:\r\n            messagebox.showwarning(\r\n                \"No English terms found\",\r\n                \"I couldn’t find English items. Put one per line or comma-separated.\"\r\n            )\r\n            return\r\n\r\n        # Do the work in a thread\r\n        def run():\r\n            self._set_buttons_enabled(False)\r\n            self._safe_after(0, self.log, f\"Translating {len(english_terms)} English items…\")\r\n            try:\r\n                # Reload the translator module so edits take effect without restarting the app\r\n                import importlib\r\n                import From_English_Translate as FET\r\n                importlib.reload(FET)\r\n\r\n                rows = FET.translate_english_terms_batch(\r\n                    english_terms,\r\n                    model=\"gpt-4o-mini\",\r\n                    batch_size=25,\r\n                    retries=2,\r\n                )\r\n                if not rows:\r\n                    self._safe_after(0, self.log, \"Translator returned 0 rows.\", False)\r\n                    messagebox.showerror(\"Translation failed\", \"Got no rows back from the model.\")\r\n                    return\r\n\r\n                # Merge into table (append behavior like your other flows)\r\n                self.rows.extend(rows)\r\n                self._safe_after(0, self.refresh_table)\r\n                self._safe_after(0, self.log, f\"Translated {len(rows)} rows from English input.\")\r\n            except Exception as e:\r\n                msg = str(e)\r\n                self._safe_after(0, self.log, f\"[EN→JP batch] {msg}\", False)\r\n                messagebox.showerror(\"Translation failed\", msg[:500])\r\n            finally:\r\n                self._safe_after(0, self._set_buttons_enabled, True)\r\n\r\n        threading.Thread(target=run, daemon=True).start()\r\n\r\n    # ----- Anki export -----\r\n    def on_make_anki(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to export\", \"Parse first, then make an Anki deck.\")\r\n            return\r\n\r\n        default_name = f\"JP Vocab ({datetime.today().strftime('%Y-%m-%d')})\"\r\n        deck_name = simpledialog.askstring(\"Deck name\", \"Enter Anki deck name:\", initialvalue=default_name)\r\n        if not deck_name:\r\n            return\r\n\r\n        out_path = filedialog.asksaveasfilename(\r\n            title=\"Save Anki Deck\",\r\n            defaultextension=\".apkg\",\r\n            filetypes=[(\"Anki package\", \"*.apkg\"), (\"All files\", \"*.*\")],\r\n        )\r\n        if not out_path:\r\n            return\r\n\r\n        try:\r\n            deck = make_anki_deck(self.rows, deck_name)\r\n            genanki.Package(deck).write_to_file(out_path)\r\n            self.status.config(text=f\"Anki deck saved: {out_path}\")\r\n            messagebox.showinfo(\"Done\", f\"Anki deck saved:\\n{out_path}\")\r\n        except Exception as e:\r\n            messagebox.showerror(\"Anki export error\", str(e))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    App().mainloop()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py b/v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py
--- a/v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py	(revision 9bc9320c1a83230db43a4ef43e60991a50bb6734)
+++ b/v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py	(date 1761997244680)
@@ -1,8 +1,7 @@
 # From English
 from From_English_Translate import translate_english_terms_batch
-
+## TEST GIT
 # -*- coding: utf-8 -*-
-import re
 import csv
 import hashlib
 from datetime import datetime
@@ -17,6 +16,7 @@
 import re
 from typing import Iterable, Dict, List
 from extractor import build_rows_from_text
+from typing import Iterable, List
 
 # Jisho
 from jisho_api.word import Word
@@ -49,19 +49,40 @@
 # OpenAI
 from openai import OpenAI
 
-# ---------------- OpenAI helpers ----------------
-_client = OpenAI()
+# # ---------------- OpenAI helpers ----------------
+# _client = OpenAI()
+#
+#
+# def get_openai_client() -> OpenAI:
+#     """Lazy-load the OpenAI client (env var OPENAI_API_KEY or fallback file)."""
+#     global _client
+#     if _client is None:
+#         api_key = os.getenv("OPENAI_API_KEY")
+#         if not api_key:
+#             key_file = Path(__file__).resolve().parent / ".venv" / "Lib" / "site-packages" / "OPENAI_API_KEY.txt"
+#             api_key = key_file.read_text(encoding="utf-8").strip()
+#         _client = OpenAI(api_key=api_key)
+#     return _client
 
+_client = None
 
 def get_openai_client() -> OpenAI:
-    """Lazy-load the OpenAI client (env var OPENAI_API_KEY or fallback file)."""
     global _client
-    if _client is None:
-        api_key = os.getenv("OPENAI_API_KEY")
-        if not api_key:
-            key_file = Path(__file__).resolve().parent / ".venv" / "Lib" / "gpt_api_secret.txt"
-            api_key = key_file.read_text(encoding="utf-8").strip()
-        _client = OpenAI(api_key=api_key)
+    if _client is not None:
+        return _client
+
+    api_key = os.getenv("OPENAI_API_KEY")
+    if not api_key:
+        key_file = Path(__file__).resolve().parent / "OPENAI_API_KEY.txt"
+        if not key_file.exists():
+            raise FileNotFoundError(f"❌ API key file not found at {key_file}")
+        api_key = key_file.read_text(encoding="utf-8").strip()
+        os.environ["OPENAI_API_KEY"] = api_key   # ← make it visible to other modules
+
+    if not api_key.startswith(("sk-", "sk-proj-")) or any(c in api_key for c in (" ", "\t", "\n", "\r")):
+        raise ValueError("❌ Invalid API key format.")
+
+    _client = OpenAI(api_key=api_key)
     return _client
 
 def _extract_json(text: str) -> str:
@@ -423,22 +444,23 @@
         parts.append(last)
     return parts
 
-# Matches entries like:  一般的（いっぱんてき） general, common, typical
-# …and also tolerates missing readings:  一般的  general, common
-TERM_BLOCK_RE = re.compile(r"""
+# Token that contains at least one Japanese char (Hiragana/Katakana/Kanji)
+JP_TOKEN = r"(?:[^\s（）()]*[\u3040-\u30FF\u3400-\u9FFF][^\s（）()]*)"
+
+TERM_BLOCK_RE = re.compile(rf"""
     \s*                                  # optional leading space
-    (?P<term>[^\s（）()]+)                # term (until space or bracket)
+    (?P<term>{JP_TOKEN})                 # JP term must include JP chars
     (?:\s*[（(](?P<reading>[^）)]+)[）)])? # optional reading in JP/ASCII parens
     \s+                                  # at least one space
     (?P<meaning>.+?)                     # meaning (lazy)
-    (?=                                  # stop when we see the next term…
-        \s+[^\s（）()]+(?:\s*[（(][^）)]+[）)])? # …optionally with reading…
-        \s+                              # …and a space
+    (?=                                  # stop when we see the next *JP* term…
+        \s+{JP_TOKEN}(?:\s*[（(][^）)]+[）)])?\s+  # next JP term (optional reading)
       | \s*$                             # …or end of string
     )
 """, re.VERBOSE | re.DOTALL)
 
 
+
 def parse_blob(text: str):
     text = re.sub(r"\s+", " ", text.strip())
     rows = []
@@ -621,7 +643,12 @@
         controls_frame.pack(fill="x", padx=10, pady=6)
 
         # Topic service (reused)
-        self.topic_service = TopicGeneratorService(augment_row_with_jisho=augment_row_with_jisho)
+        client = get_openai_client()  # ensures the correct key + client are used
+        self.topic_service = TopicGeneratorService(
+            augment_row_with_jisho=augment_row_with_jisho,
+            client=client,  # inject the working client
+            model="gpt-4o-mini",
+        )
 
         # Theming
         if tb:
@@ -816,26 +843,6 @@
             self.sa_entry.delete(0, tk.END)
             self.sa_entry.insert(0, path)
 
-
-        def toggle(self):
-            self._open = not self._open
-            self._sync()
-
-        def open(self):
-            self._open = True
-            self._sync()
-
-        def close(self):
-            self._open = False
-            self._sync()
-
-        def _sync(self):
-            self._glyph.config(text="▾" if self._open else "▸")
-            if self._open:
-                self.content.pack(fill="both", expand=True)
-            else:
-                self.content.forget()
-
     def on_parse(self):
         raw = self.text.get("1.0", "end-1c")
         self.rows = parse_blob(raw)
@@ -1363,4 +1370,5 @@
 
 
 if __name__ == "__main__":
+    get_openai_client()   # ensures OPENAI_API_KEY is set for TopicService / translator
     App().mainloop()
Index: topic_service.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># topic_service.py\r\nfrom __future__ import annotations\r\nfrom typing import Callable, Iterable, List, Tuple, Set, Dict\r\nimport json\r\nimport time\r\nimport os\r\nfrom openai import OpenAI\r\nimport re, json\r\n\r\n\r\ndef _norm(s: str) -> str:\r\n    return (s or \"\").strip()\r\n\r\ndef _key(term: str, reading: str) -> Tuple[str, str]:\r\n    return (_norm(term), _norm(reading))\r\n\r\nimport re, json\r\n\r\ndef _extract_json_block(text: str) -> str:\r\n    \"\"\"Prefer fenced ```json blocks; else return the largest {...} or [...] found.\"\"\"\r\n    if not text:\r\n        return \"{}\"\r\n    m = re.search(r\"```json\\s*(.+?)\\s*```\", text, flags=re.DOTALL|re.IGNORECASE)\r\n    if m:\r\n        return m.group(1).strip()\r\n    # else grab biggest object/array\r\n    obj = (text.find(\"{\"), text.rfind(\"}\"))\r\n    arr = (text.find(\"[\"), text.rfind(\"]\"))\r\n    if obj[0] != -1 and obj[1] > obj[0] and (arr[1]-arr[0] <= obj[1]-obj[0]):\r\n        return text[obj[0]:obj[1]+1]\r\n    if arr[0] != -1 and arr[1] > arr[0]:\r\n        return text[arr[0]:arr[1]+1]\r\n    return text.strip()\r\n\r\ndef _lenient_json_loads(s: str):\r\n    \"\"\"\r\n    Coerce near‑JSON into JSON: fixes code fences, smart quotes, single quotes,\r\n    unquoted keys, trailing commas, and wraps top‑level arrays into {\"items\":...}.\r\n    \"\"\"\r\n    if not s:\r\n        return {}\r\n    # normalize smart quotes / NBSP\r\n    s = s.replace(\"“\",\"\\\"\").replace(\"”\",\"\\\"\").replace(\"‘\",\"'\").replace(\"’\",\"'\")\r\n    s = re.sub(r\"\\u00A0\", \" \", s)\r\n\r\n    ss = s.strip()\r\n    # if the model returned a raw array, wrap as {\"items\":[...]}\r\n    if ss.startswith(\"[\") and ss.endswith(\"]\"):\r\n        s = \"{\\\"items\\\":\"+ss+\"}\"\r\n\r\n    # quote bare keys: items: [...] -> \"items\": [...]\r\n    s = re.sub(r'(?m)(^|\\s)([A-Za-z_][A-Za-z0-9_-]*)\\s*:', r'\\1\"\\2\":', s)\r\n\r\n    # convert 'single-quoted strings' to \"double-quoted\"\r\n    def _flip(m):\r\n        inner = m.group(1)\r\n        return '\"' + inner.replace('\"', '\\\\\"') + '\"'\r\n    s = re.sub(r\"'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\", _flip, s)\r\n\r\n    # remove trailing commas before } or ]\r\n    s = re.sub(r\",\\s*([}\\]])\", r\"\\1\", s)\r\n\r\n    try:\r\n        return json.loads(s)\r\n    except Exception:\r\n        # last resort: try the largest object/array again\r\n        block = _extract_json_block(s)\r\n        if block.startswith(\"[\"):\r\n            block = \"{\\\"items\\\":\"+block+\"}\"\r\n        return json.loads(block)\r\n\r\n\r\nclass TopicGeneratorService:\r\n    \"\"\"\r\n    Generates Japanese vocab rows for a topic, guaranteeing *exactly* `count`\r\n    unique items that do NOT overlap `existing_keys` (term, reading).\r\n    Optionally enriches via Jisho.\r\n    \"\"\"\r\n    def __init__(\r\n        self,\r\n        augment_row_with_jisho: Callable[[str, str | None], List[str]] | None = None,\r\n        *,\r\n        model: str = \"gpt-4o-mini\",\r\n        temperature: float = 1,\r\n        client: OpenAI | None = None,\r\n    ):\r\n        self.augment_row_with_jisho = augment_row_with_jisho\r\n        self.model = model\r\n        self.temperature = temperature\r\n        self.client = client or OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\r\n\r\n    # ---------- PUBLIC -------------------------------------------------------\r\n    def generate_rows(\r\n        self,\r\n        topic: str,\r\n        count: int = 30,\r\n        gpt_only: bool = False,\r\n        existing_keys: Iterable[Tuple[str, str]] | None = None,\r\n    ) -> List[List[str]]:\r\n        \"\"\"\r\n        Returns exactly `count` rows: [term, reading, meaning, example, jlpt].\r\n        Avoids any (term, reading) in `existing_keys`. Will loop and ask GPT for\r\n        more until we have enough uniques (with a sensible safety cap).\r\n        \"\"\"\r\n        avoid: Set[Tuple[str, str]] = set(existing_keys or [])\r\n        collected: Dict[Tuple[str, str], List[str]] = {}\r\n\r\n        needed = count\r\n        attempt = 0\r\n        # Safety cap: plenty of chances, gradually broadening scope\r\n        while len(collected) < count and attempt < 12:\r\n            attempt += 1\r\n            remaining = count - len(collected)\r\n\r\n            # Ask for a bit more than we still need to compensate for duplicates\r\n            ask_for = min(remaining + 8, max(remaining + 4, 24))\r\n\r\n            batch = self._ask_gpt_for_topic_batch(\r\n                topic=topic,\r\n                n=ask_for,\r\n                avoid_pairs=list(avoid | set(collected.keys())),\r\n                attempt_index=attempt,\r\n            )\r\n\r\n            # Filter + collect uniques\r\n            for row in batch:\r\n                term, reading, meaning, example, jlpt = (row + [\"\", \"\", \"\", \"\", \"\"])[:5]\r\n                k = _key(term, reading)\r\n                if not k[0] or k in avoid or k in collected:\r\n                    continue\r\n                collected[k] = [term, reading, meaning, example, jlpt]\r\n                if len(collected) >= count:\r\n                    break\r\n\r\n            # gentle backoff if still short (helps with rate limits)\r\n            if len(collected) < count:\r\n                time.sleep(0.2 * attempt)\r\n\r\n        # If still short (rare), force another final pass asking for exactly the remainder\r\n        if len(collected) < count:\r\n            final_need = count - len(collected)\r\n            batch = self._ask_gpt_for_topic_batch(\r\n                topic=topic,\r\n                n=final_need + 10,\r\n                avoid_pairs=list(avoid | set(collected.keys())),\r\n                attempt_index=attempt + 1,\r\n            )\r\n            for row in batch:\r\n                term, reading, meaning, example, jlpt = (row + [\"\", \"\", \"\", \"\", \"\"])[:5]\r\n                k = _key(term, reading)\r\n                if not k[0] or k in avoid or k in collected:\r\n                    continue\r\n                collected[k] = [term, reading, meaning, example, jlpt]\r\n                if len(collected) >= count:\r\n                    break\r\n\r\n        rows = list(collected.values())\r\n\r\n        # Optional Jisho enrichment\r\n        if not gpt_only and self.augment_row_with_jisho:\r\n            enriched: List[List[str]] = []\r\n            for term, reading, meaning, example, jlpt in rows:\r\n                try:\r\n                    enriched.append(self.augment_row_with_jisho(term, reading or None))\r\n                except Exception:\r\n                    enriched.append([term, reading, meaning, example, jlpt])\r\n            rows = enriched\r\n\r\n        # Guarantee exact count (truncate in the astronomically rare case we got more)\r\n        return rows[:count]\r\n\r\n    # ---------- PRIVATE ------------------------------------------------------\r\n    def _ask_gpt_for_topic_batch(\r\n            self,\r\n            topic: str,\r\n            n: int,\r\n            avoid_pairs: List[Tuple[str, str]],\r\n            attempt_index: int,\r\n    ) -> List[List[str]]:\r\n        \"\"\"\r\n        Returns a list of rows: [term, reading, meaning, example, jlpt]\r\n        GPT is instructed to avoid `avoid_pairs` and produce unique items.\r\n        Uses lenient JSON extraction so minor format hiccups don't fail the batch.\r\n        \"\"\"\r\n        import re, json\r\n\r\n        # --- helpers -----------------------------------------------------------\r\n        def _extract_json_block(text: str) -> str:\r\n            \"\"\"Extract fenced JSON or largest {...} or [...] block.\"\"\"\r\n            if not text:\r\n                return \"{}\"\r\n            m = re.search(r\"```json\\s*(.+?)\\s*```\", text, flags=re.DOTALL | re.IGNORECASE)\r\n            if m:\r\n                return m.group(1).strip()\r\n            obj = (text.find(\"{\"), text.rfind(\"}\"))\r\n            arr = (text.find(\"[\"), text.rfind(\"]\"))\r\n            if obj[0] != -1 and obj[1] > obj[0] and (arr[1] - arr[0] <= obj[1] - obj[0]):\r\n                return text[obj[0]: obj[1] + 1]\r\n            if arr[0] != -1 and arr[1] > arr[0]:\r\n                return text[arr[0]: arr[1] + 1]\r\n            return text.strip()\r\n\r\n        def _lenient_json_loads(s: str):\r\n            \"\"\"Coerce near-JSON into JSON: fix quotes, trailing commas, wrap arrays.\"\"\"\r\n            if not s:\r\n                return {}\r\n            s = s.replace(\"“\", \"\\\"\").replace(\"”\", \"\\\"\").replace(\"‘\", \"'\").replace(\"’\", \"'\")\r\n            s = re.sub(r\"\\u00A0\", \" \", s)\r\n\r\n            ss = s.strip()\r\n            if ss.startswith(\"[\") and ss.endswith(\"]\"):\r\n                s = \"{\\\"items\\\":\" + ss + \"}\"\r\n\r\n            # quote bare keys\r\n            s = re.sub(r'(?m)(^|\\s)([A-Za-z_][A-Za-z0-9_-]*)\\s*:', r'\\1\"\\2\":', s)\r\n\r\n            # convert 'strings' → \"strings\"\r\n            def _flip(m):\r\n                inner = m.group(1)\r\n                return '\"' + inner.replace('\"', '\\\\\"') + '\"'\r\n\r\n            s = re.sub(r\"'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\", _flip, s)\r\n\r\n            # remove trailing commas\r\n            s = re.sub(r\",\\s*([}\\]])\", r\"\\1\", s)\r\n\r\n            try:\r\n                return json.loads(s)\r\n            except Exception:\r\n                block = _extract_json_block(s)\r\n                if block.startswith(\"[\"):\r\n                    block = \"{\\\"items\\\":\" + block + \"}\"\r\n                return json.loads(block)\r\n\r\n        def _norm(x: str) -> str:\r\n            return (x or \"\").strip()\r\n\r\n        def _is_kana(s: str) -> bool:\r\n            return bool(s) and all(\r\n                ('\\u3040' <= ch <= '\\u309f') or ('\\u30a0' <= ch <= '\\u30ff') or ch in ('・', 'ー')\r\n                for ch in s\r\n            )\r\n\r\n        def _has_ascii_letters(s: str) -> bool:\r\n            return bool(re.search(r\"[A-Za-z]\", s or \"\"))\r\n\r\n        # --- guidance rules ----------------------------------------------------\r\n        avoid_str = \"; \".join([f\"{t}|{r}\" for t, r in avoid_pairs[:250]])\r\n        guidance = [\r\n            \"Return unique items only; no duplicates within output.\",\r\n            \"Do not include any pair present in 'avoid_pairs'.\",\r\n            \"term MUST be Japanese (kanji/kana). Never output the English seed as term.\",\r\n            \"reading must be kana (hiragana/katakana).\",\r\n            \"meaning should be brief English gloss(es).\",\r\n            \"example must be ONE natural Japanese sentence (約60–110文字) that includes the exact JP term string, \"\r\n            \"and reads context‑rich (news/academic/professional tone).\",\r\n            \"jlpt is one of N5,N4,N3,N2,N1 or empty if unknown.\",\r\n            \"Prefer common equivalents over katakana unless the loanword is standard.\",\r\n            \"Sentences should feel context-rich (news, academic, professional, thoughtful).\",\r\n        ]\r\n        if attempt_index >= 3:\r\n            guidance.append(\"Choose more specific or less common items still clearly within the topic.\")\r\n        if attempt_index >= 6:\r\n            guidance.append(\"Consider adjacent subtopics to avoid repeats while staying relevant.\")\r\n        if attempt_index >= 9:\r\n            guidance.append(\"Avoid very high-frequency duplicates; diversify parts of speech.\")\r\n\r\n        # --- prompts -----------------------------------------------------------\r\n        sys_prompt = (\r\n            \"You are a meticulous Japanese vocabulary generator. \"\r\n            \"Respond with STRICT JSON only. No prose, no comments.\"\r\n        )\r\n        user_payload = {\r\n            \"instruction\": \"Generate Japanese vocabulary strictly as JSON with key 'items'.\",\r\n            \"topic\": topic,\r\n            \"count\": n,\r\n            \"avoid_pairs\": avoid_str,\r\n            \"rules\": guidance,\r\n            \"schema\": {\r\n                \"term\": \"Kanji or kana headword (JP only).\",\r\n                \"reading\": \"Hiragana or katakana reading.\",\r\n                \"meaning\": \"Short English gloss.\",\r\n                \"example\": \"One medium-length Japanese sentence that includes the JP term.\",\r\n                \"jlpt\": \"N5|N4|N3|N2|N1 or empty.\",\r\n            },\r\n        }\r\n\r\n        # --- API call ----------------------------------------------------------\r\n        try:\r\n            resp = self.client.chat.completions.create(\r\n                model=self.model,\r\n                temperature=self.temperature,\r\n                response_format={\"type\": \"json_object\"},\r\n                messages=[\r\n                    {\"role\": \"system\", \"content\": sys_prompt},\r\n                    {\"role\": \"user\", \"content\": json.dumps(user_payload, ensure_ascii=False)},\r\n                ],\r\n                max_tokens=1800,\r\n            )\r\n            content = resp.choices[0].message.content or \"{}\"\r\n        except Exception as e:\r\n            print(f\"[TopicService request error] {e}\")\r\n            return []\r\n\r\n        # --- parse & validate --------------------------------------------------\r\n        try:\r\n            raw_json = _extract_json_block(content)\r\n            data = _lenient_json_loads(raw_json)\r\n        except Exception as e:\r\n            print(f\"[TopicService JSON parse error] {e} | snippet: {content[:400]}\")\r\n            return []\r\n\r\n        raw_items = (data.get(\"items\") if isinstance(data, dict) else None) or []\r\n        if not isinstance(raw_items, list):\r\n            raw_items = [raw_items] if raw_items else []\r\n\r\n        rows: List[List[str]] = []\r\n        for it in raw_items:\r\n            term = _norm(it.get(\"term\"))\r\n            reading = _norm(it.get(\"reading\"))\r\n            meaning = _norm(it.get(\"meaning\"))\r\n            example = _norm(it.get(\"example\"))\r\n            jlpt = _norm(it.get(\"jlpt\"))\r\n\r\n            if not term or _has_ascii_letters(term):\r\n                continue\r\n            if reading and not _is_kana(reading):\r\n                continue\r\n            if example and term not in example:\r\n                continue\r\n\r\n            rows.append([term, reading, meaning, example, jlpt])\r\n\r\n        # de-dupe\r\n        uniq: Dict[Tuple[str, str], List[str]] = {}\r\n        for row in rows:\r\n            k = (row[0], row[1])\r\n            if k not in uniq:\r\n                uniq[k] = row\r\n        return list(uniq.values())\r\n\r\n        # if still failing\r\n        snippet = (raw_reply[:200] + \"…\") if raw_reply else \"\"\r\n        raise RuntimeError(f\"[Topic batch] failed after retries: {last_err} | reply snippet: {snippet}\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/topic_service.py b/topic_service.py
--- a/topic_service.py	(revision 9bc9320c1a83230db43a4ef43e60991a50bb6734)
+++ b/topic_service.py	(date 1761997086992)
@@ -76,18 +76,12 @@
     unique items that do NOT overlap `existing_keys` (term, reading).
     Optionally enriches via Jisho.
     """
-    def __init__(
-        self,
-        augment_row_with_jisho: Callable[[str, str | None], List[str]] | None = None,
-        *,
-        model: str = "gpt-4o-mini",
-        temperature: float = 1,
-        client: OpenAI | None = None,
-    ):
+
+    def __init__(self, augment_row_with_jisho=None, *, model="gpt-4o-mini", temperature=1.0, client=None):
         self.augment_row_with_jisho = augment_row_with_jisho
         self.model = model
         self.temperature = temperature
-        self.client = client or OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
+        self.client = client or OpenAI()  # ← fine, but won’t be used if you inject
 
     # ---------- PUBLIC -------------------------------------------------------
     def generate_rows(
Index: Scen2.1.Clean_Augment_Japanese_App_List_Data.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import re\r\nimport csv\r\nimport hashlib\r\nfrom datetime import datetime\r\nfrom pathlib import Path\r\nimport time\r\nimport tkinter as tk\r\nfrom tkinter import ttk, filedialog, messagebox, simpledialog\r\nfrom jisho_api.word import Word\r\nfrom jisho_api.sentence import Sentence\r\nimport threading\r\nfrom topic_service import TopicGeneratorService\r\nfrom utils import merge_rows  # <-- your utils.py\r\n\r\n# THEMES\r\ntry:\r\n    import ttkbootstrap as tb\r\nexcept Exception:\r\n    tb = None\r\n\r\ntry:\r\n    import sv_ttk\r\nexcept Exception:\r\n    sv_ttk = None\r\n\r\n# --- Google APIs (optional if you only want CSV/Anki) ---\r\nfrom google.oauth2 import service_account\r\nfrom googleapiclient.discovery import build\r\nfrom googleapiclient.errors import HttpError\r\n\r\n# --- Anki ---\r\nimport genanki\r\n\r\n# --- Open AI ---\r\nfrom openai import OpenAI\r\nimport os\r\n\r\n_client = OpenAI()\r\n\r\ndef get_openai_client() -> OpenAI:\r\n    \"\"\"Lazy-load the OpenAI client (env var OPENAI_API_KEY or fallback file).\"\"\"\r\n    global _client\r\n    if _client is None:\r\n        api_key = os.getenv(\"OPENAI_API_KEY\")\r\n        if not api_key:\r\n            key_file = Path(__file__).resolve().parent / \".venv\" / \"Lib\" / \"gpt_api_secret.txt\"\r\n            api_key = key_file.read_text(encoding=\"utf-8\").strip()\r\n        _client = OpenAI(api_key=api_key)\r\n    return _client\r\n\r\n\r\n\r\ndef generate_example_with_gpt(term: str) -> str:\r\n    \"\"\"Return a short Japanese example sentence using the supplied term.\"\"\"\r\n    client = get_openai_client()\r\n    prompt = (\r\n        f\"Output ONLY one short natural Japanese example sentence using the word '{term}'. \"\r\n        \"Do not include translations, explanations, or any other text.\"\r\n    )\r\n    resp = client.chat.completions.create(\r\n        model=\"gpt-4o-mini\",\r\n        messages=[{\"role\": \"user\", \"content\": prompt}],\r\n        max_tokens=60,\r\n        temperature=0.7,\r\n    )\r\n    # ✅ current SDK uses attribute access\r\n    # safer: handle SDK object and possible missing content\r\n    msg = resp.choices[0].message\r\n    text = getattr(msg, \"content\", \"\") or \"\"\r\n    return text.strip()\r\n\r\n# ------------- Parsing logic -------------\r\nTERM_BLOCK_RE = re.compile(r'([^\\s（]+)（([^）]+)）\\s+(.+?)(?=\\s+[^\\s（]+（[^）]+）|\\s*$)')\r\n\r\nFURIGANA_RE = re.compile(r\"\\([^)]*\\)\")\r\n\r\ndef remove_furigana(text: str) -> str:\r\n    return FURIGANA_RE.sub(\"\", text)\r\n\r\ndef top_two_non_wiki_meanings(w_data) -> str:\r\n    picked = []\r\n    for sense in w_data.senses:\r\n        if \"Wikipedia definition\" in (sense.parts_of_speech or []):\r\n            continue\r\n        if sense.english_definitions:\r\n            picked.append(\", \".join(sense.english_definitions))\r\n        if len(picked) >= 2:\r\n            break\r\n    return \"; \".join(picked[:2]) if picked else \"\"\r\n\r\ndef fetch_example_sentence(term: str) -> str:\r\n    try:\r\n        s_res = Sentence.request(term)\r\n        if s_res.data:\r\n            return remove_furigana(s_res.data[0].japanese)\r\n    except Exception:\r\n        pass\r\n    return \"\"\r\n\r\ndef augment_row_with_jisho(term: str, reading_hint: str | None) -> list[str]:\r\n    \"\"\"\r\n    Returns: [Term, Reading, Meaning(2 max, non-Wikipedia), Example, JLPT]\r\n    \"\"\"\r\n    w_res = Word.request(term)\r\n    if not w_res.data and reading_hint:\r\n        w_res = Word.request(reading_hint)\r\n    if not w_res.data:\r\n        return [term, reading_hint or \"\", \"\", \"\", \"\"]\r\n\r\n    w = w_res.data[0]\r\n    jp0 = w.japanese[0]\r\n    out_term = jp0.word or jp0.reading or term\r\n    out_reading = jp0.reading or (reading_hint or \"\")\r\n    meanings = top_two_non_wiki_meanings(w)\r\n    example = fetch_example_sentence(term)\r\n    jlpt = \", \".join(w.jlpt) if w.jlpt else \"\"\r\n\r\n    return [out_term, out_reading, meanings or \"\", example, jlpt]\r\n\r\ndef split_meanings(s: str):\r\n    \"\"\"Split on commas not inside ASCII parentheses; keep semicolons as-is.\"\"\"\r\n    parts, current, depth = [], [], 0\r\n    for ch in s:\r\n        if ch == '(':\r\n            depth += 1\r\n        elif ch == ')' and depth > 0:\r\n            depth -= 1\r\n        if ch == ',' and depth == 0:\r\n            part = ''.join(current).strip()\r\n            if part:\r\n                parts.append(part)\r\n            current = []\r\n        else:\r\n            current.append(ch)\r\n    last = ''.join(current).strip()\r\n    if last:\r\n        parts.append(last)\r\n    return parts\r\n\r\ndef parse_blob(text: str):\r\n    \"\"\"\r\n    Return list of [Term, Reading, Meaning, Example, JLPT].\r\n    Example and JLPT are empty strings at parse time; the Jisho augment fills them later.\r\n    \"\"\"\r\n    text = re.sub(r\"\\s+\", \" \", text.strip())\r\n    rows = []\r\n    for m in TERM_BLOCK_RE.finditer(text):\r\n        term = m.group(1).strip()\r\n        reading = m.group(2).strip()\r\n        meanings_raw = m.group(3).strip()\r\n        meanings = \", \".join(split_meanings(meanings_raw))\r\n        rows.append([term, reading, meanings, \"\", \"\"])  # <-- pad Example, JLPT\r\n    return rows\r\n\r\n\r\n# ------------- Google Sheets helpers -------------\r\nSCOPES = [\"https://www.googleapis.com/auth/spreadsheets\"]\r\n\r\ndef get_service(sa_json_path: str):\r\n    creds = service_account.Credentials.from_service_account_file(sa_json_path, scopes=SCOPES)\r\n    return build(\"sheets\", \"v4\", credentials=creds)\r\n\r\ndef ensure_sheet_exists(service, spreadsheet_id: str, title: str):\r\n    meta = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\r\n    if any(s.get(\"properties\", {}).get(\"title\") == title for s in meta.get(\"sheets\", [])):\r\n        return\r\n    service.spreadsheets().batchUpdate(\r\n        spreadsheetId=spreadsheet_id,\r\n        body={\"requests\": [{\"addSheet\": {\"properties\": {\"title\": title}}}]},\r\n    ).execute()\r\n\r\ndef write_to_sheet(service, sheet_id: str, tab: str, rows: list,\r\n                   write_headers=True, clear_body=True):\r\n    \"\"\"Write headers and rows; adapts to 3 or 5 columns based on data.\"\"\"\r\n    values_api = service.spreadsheets().values()\r\n    width = max(len(r) for r in rows) if rows else 3\r\n    if width >= 5:\r\n        headers = [\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\"]\r\n        header_range = f\"{tab}!A1:E1\"\r\n        clear_range = f\"{tab}!A2:E\"\r\n        write_start = f\"{tab}!A2\"\r\n    else:\r\n        headers = [\"Term\", \"Reading\", \"Meaning\"]\r\n        header_range = f\"{tab}!A1:C1\"\r\n        clear_range = f\"{tab}!A2:C\"\r\n        write_start = f\"{tab}!A2\"\r\n\r\n    if write_headers:\r\n        values_api.update(\r\n            spreadsheetId=sheet_id,\r\n            range=header_range,\r\n            valueInputOption=\"USER_ENTERED\",\r\n            body={\"values\": [headers]},\r\n        ).execute()\r\n    if clear_body:\r\n        values_api.clear(spreadsheetId=sheet_id, range=clear_range).execute()\r\n    if rows:\r\n        # pad each row to width\r\n        padded = [(r + [\"\", \"\", \"\"])[:len(headers)] for r in rows]\r\n        values_api.update(\r\n            spreadsheetId=sheet_id,\r\n            range=write_start,\r\n            valueInputOption=\"USER_ENTERED\",\r\n            body={\"values\": padded},\r\n        ).execute()\r\n\r\n\r\ndef read_from_sheet(service, sheet_id: str, tab: str) -> list:\r\n    \"\"\"Read Term/Reading/Meaning rows (columns A:D) from a sheet.\"\"\"\r\n    values = service.spreadsheets().values().get(\r\n        spreadsheetId=sheet_id,\r\n        range=f\"{tab}!A:E\",\r\n    ).execute().get(\"values\", [])\r\n    rows = []\r\n    for r in values[1:]:  # drop header row\r\n        padded = (r + [\"\", \"\", \"\"])[:5]\r\n        if any(c.strip() for c in padded):\r\n            rows.append(padded)\r\n    return rows\r\n\r\n\r\ndef backup_raw(service, sheet_id: str, backup_tab: str, raw_text: str):\r\n    ensure_sheet_exists(service, sheet_id, backup_tab)\r\n    ts = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\n    service.spreadsheets().values().append(\r\n        spreadsheetId=sheet_id,\r\n        range=f\"{backup_tab}!A:B\",\r\n        valueInputOption=\"RAW\",\r\n        insertDataOption=\"INSERT_ROWS\",\r\n        body={\"values\": [[ts, raw_text]]},\r\n    ).execute()\r\n\r\n\r\n\r\n# ------------- Anki helpers -------------\r\ndef stable_id(name: str) -> int:\r\n    \"\"\"Deterministic 32-bit int from a name (for deck/model IDs).\"\"\"\r\n    return int(hashlib.sha1(name.encode(\"utf-8\")).hexdigest()[:8], 16)\r\n\r\ndef make_anki_deck(rows: list, deck_name: str):\r\n    \"\"\"\r\n    Build a genanki.Deck from rows = [[Term, Reading, Meaning, Example, JLPT], ...].\r\n    Uses a model with 6 fields: Term, Reading, Meaning, Example, JLPT, Date.\r\n    \"\"\"\r\n    deck_id = stable_id(deck_name)\r\n    model_name = \"JP Vocab Basic v3\"\r\n    model_id = stable_id(model_name)\r\n\r\n    model = genanki.Model(\r\n        model_id=model_id,\r\n        name=model_name,\r\n        fields=[\r\n            {\"name\": \"Term\"},\r\n            {\"name\": \"Reading\"},\r\n            {\"name\": \"Meaning\"},\r\n            {\"name\": \"Example\"},\r\n            {\"name\": \"JLPT\"},\r\n            {\"name\": \"Date\"},\r\n        ],\r\n        templates=[\r\n            {\r\n                \"name\": \"Card 1\",\r\n                \"qfmt\": \"\"\"\r\n<div style=\"display:flex;align-items:center;justify-content:center;min-height:65vh;font-size:60px;font-weight:700;\">\r\n  {{Term}}\r\n</div>\r\n                \"\"\",\r\n                \"afmt\": \"\"\"\r\n<div style=\"display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:65vh;padding:10px;color:#fff !important;\">\r\n  <div style=\"font-size:60px;font-weight:700;\">{{Term}}</div>\r\n  <div style=\"font-size:34px;margin-top:10px;\">{{Reading}}</div>\r\n  <hr style=\"width:100%;border:none;border-top:1px solid #aaa;margin:16px 0;\">\r\n  <div style=\"font-size:28px;line-height:1.4;text-align:center;max-width:900px;\">\r\n    {{Meaning}}\r\n  </div>\r\n  {{#Example}}\r\n  <div style=\"margin-top:16px;font-size:24px;line-height:1.4;text-align:center;max-width:900px;\">\r\n    <b>Example:</b> {{Example}}\r\n  </div>\r\n  {{/Example}}\r\n  {{#JLPT}}\r\n  <div style=\"margin-top:12px;font-size:18px;color:#ddd;\">\r\n    JLPT: {{JLPT}}\r\n  </div>\r\n  {{/JLPT}}\r\n  <div style=\"font-size:14px;color:#eaeaea;margin-top:16px;\">\r\n    Added: {{Date}}\r\n  </div>\r\n</div>\r\n\"\"\"\r\n            }\r\n        ],\r\n    )\r\n\r\n    deck = genanki.Deck(deck_id=deck_id, name=deck_name)\r\n    today = datetime.today().strftime(\"%Y-%m-%d\")\r\n\r\n    for row in rows:\r\n        # pad to 5 fields if needed\r\n        term, reading, meaning, example, jlpt = (row + [\"\", \"\", \"\"])[:5]\r\n        guid = genanki.guid_for(f\"v3|{term}|{reading}\")  # version tag to avoid collision\r\n        note = genanki.Note(\r\n            model=model,\r\n            fields=[term, reading, meaning, example, jlpt, today],\r\n            guid=guid,\r\n        )\r\n        deck.add_note(note)\r\n\r\n    return deck\r\n\r\n\r\n# ------------- GUI -------------\r\nclass App(tk.Tk):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.title(\"Japanese Vocab Parser → CSV / Google Sheets / Anki\")\r\n        self.geometry(\"1000x680\")\r\n\r\n        controls_frame = ttk.Frame(self)\r\n        controls_frame.pack(fill=\"x\", padx=10, pady=6)\r\n\r\n\r\n        # 1) Create the service once and reuse\r\n        self.topic_service = TopicGeneratorService(augment_row_with_jisho=augment_row_with_jisho)\r\n\r\n        # Pick best-available theming\r\n        if tb:\r\n            tb.Style(\"darkly\")  # nice light theme; try \"darkly\" for dark\r\n        elif sv_ttk:\r\n            sv_ttk.set_theme(\"dark\")\r\n        else:\r\n            ttk.Style().theme_use(\"clam\")\r\n\r\n        # in App.__init__(), after creating the root\r\n        self.option_add(\"*Font\", (\"Segoe UI\", 10))\r\n        style = ttk.Style()\r\n        style.configure(\"TButton\", padding=(10, 6))\r\n        style.configure(\"TRadiobutton\", padding=(6, 2))\r\n        style.configure(\"TCheckbutton\", padding=(6, 2))\r\n        style.configure(\"Treeview.Heading\", font=(\"Segoe UI Semibold\", 10))\r\n        style.configure(\"Treeview\", rowheight=26)\r\n\r\n        # 2) Add minimal UI controls\r\n        self.topic_var = tk.StringVar()\r\n        self.topic_count_var = tk.IntVar(value=30)\r\n        self.gpt_only_var = tk.BooleanVar(value=False)\r\n\r\n        ttk.Label(controls_frame, text=\"Topic:\").grid(row=0, column=0, padx=4, pady=4, sticky=\"w\")\r\n        ttk.Entry(controls_frame, textvariable=self.topic_var, width=24).grid(row=0, column=1, padx=4, pady=4, sticky=\"we\")\r\n        ttk.Label(controls_frame, text=\"Items:\").grid(row=0, column=2, padx=4, pady=4, sticky=\"e\")\r\n        ttk.Spinbox(controls_frame, from_=5, to=200, textvariable=self.topic_count_var, width=6).grid(row=0, column=3, padx=4, pady=4)\r\n        ttk.Checkbutton(controls_frame, text=\"GPT only\", variable=self.gpt_only_var).grid(row=0, column=4, padx=6)\r\n        ttk.Button(controls_frame, text=\"Generate from Topic\", command=self.on_generate_from_topic).grid(row=0, column=5, padx=6)\r\n        self.append_var = tk.BooleanVar(value=True)  # default: append\r\n        ttk.Checkbutton(controls_frame, text=\"Append\", variable=self.append_var).grid(row=0, column=6, padx=6)\r\n\r\n        # State\r\n        self.rows = []\r\n        self.only_fill_empty_var = tk.BooleanVar(value=True)\r\n\r\n        # Top frame: inputs + buttons\r\n        top = ttk.Frame(self, padding=8)\r\n        top.pack(side=tk.TOP, fill=tk.X)\r\n\r\n        # Raw input\r\n        ttk.Label(top, text=\"Paste raw vocab text:\").grid(row=0, column=0, sticky=\"w\")\r\n        self.text = tk.Text(top, height=8, wrap=\"word\")\r\n        self.text.grid(row=1, column=0, columnspan=6, sticky=\"nsew\", pady=(4, 8))\r\n        text_scroll = ttk.Scrollbar(top, orient=\"vertical\", command=self.text.yview)\r\n        text_scroll.grid(row=1, column=6, sticky=\"ns\")\r\n        self.text.configure(yscrollcommand=text_scroll.set)\r\n\r\n        # Google config\r\n        ttk.Label(top, text=\"Service Account JSON:\").grid(row=2, column=0, sticky=\"w\", pady=(2, 0))\r\n        self.sa_entry = ttk.Entry(top, width=60)\r\n        self.sa_entry.grid(row=2, column=1, columnspan=4, sticky=\"we\", padx=(4, 4))\r\n\r\n        # ✅ Insert your default path\r\n        default_sa_path = r\"C:/Users/Tom/OneDrive/Coding Projects/Japanese_App_BackUp_Words/.venv/Scripts/python-fs-automation-3181504752ca.json\"\r\n        self.sa_entry.insert(0, default_sa_path)\r\n\r\n        ttk.Button(top, text=\"Browse…\", command=self.browse_sa).grid(row=2, column=5, sticky=\"w\")\r\n\r\n        ttk.Label(top, text=\"Sheet ID:\").grid(row=3, column=0, sticky=\"w\", pady=(2, 0))\r\n        self.sheet_entry = ttk.Entry(top, width=60)\r\n        self.sheet_entry.grid(row=3, column=1, columnspan=4, sticky=\"we\", padx=(4, 4))\r\n\r\n        ttk.Label(top, text=\"Tab name:\").grid(row=4, column=0, sticky=\"w\", pady=(2, 0))\r\n        self.tab_entry = ttk.Entry(top, width=20)\r\n        self.tab_entry.insert(0, \"List_Test_Data\")\r\n        self.tab_entry.grid(row=4, column=1, sticky=\"w\")\r\n\r\n        ttk.Label(top, text=\"Backup tab:\").grid(row=4, column=2, sticky=\"e\")\r\n        self.backup_tab_entry = ttk.Entry(top, width=20)\r\n        self.backup_tab_entry.insert(0, \"Raw_Backup\")\r\n        self.backup_tab_entry.grid(row=4, column=3, sticky=\"w\", padx=(4, 4))\r\n        self.backup_var = tk.BooleanVar(value=True)\r\n        ttk.Checkbutton(top, text=\"Backup raw input\", variable=self.backup_var).grid(row=4, column=4, sticky=\"w\")\r\n\r\n        # Toggle\r\n        ttk.Checkbutton(top, text=\"Only fill empty Example\",\r\n                        variable=self.only_fill_empty_var).grid(row=4, column=5, sticky=\"w\")\r\n\r\n        # Buttons\r\n        btns = ttk.Frame(top)\r\n        btns.grid(row=5, column=0, columnspan=6, sticky=\"w\", pady=(10, 4))\r\n        self._buttons = []\r\n        style.configure(\"Tool.TButton\", padding=(12, 6))\r\n\r\n        def _add_btn(text, cmd):\r\n            b = ttk.Button(btns, text=text, command=cmd, style=\"Tool.TButton\")\r\n            b.pack(side=tk.LEFT, padx=6)\r\n\r\n        _add_btn(\"Parse\uD83E\uDDFE\", self.on_parse)\r\n        _add_btn(\"Save CSV\uD83D\uDCBE\", self.on_save_csv)\r\n        _add_btn(\"Read from Google Sheet⬇\uFE0F\", self.on_read_sheet)\r\n        _add_btn(\"Write to Google Sheet⬆\uFE0F\", self.on_write_sheet)\r\n        _add_btn(\"Make Anki Deck\uD83C\uDCCF\", self.on_make_anki)\r\n        _add_btn(\"Augment Examples✨\", self.on_augment_examples)\r\n        _add_btn(\"Clear\uD83E\uDDF9\", self.on_clear)\r\n\r\n        # --- Source mode controls ---\r\n        self.source_mode = tk.IntVar(value=2)  # 0=Jisho only, 1=GPT only, 2=Jisho→GPT\r\n\r\n        # one separator to divide toolbar and options\r\n        ttk.Separator(top, orient=\"horizontal\").grid(row=6, column=0, columnspan=6, sticky=\"we\", pady=(8, 8))\r\n\r\n        # labelled group FOR radios (single instance)\r\n        mode_row = ttk.LabelFrame(top, text=\"Example source\")\r\n        mode_row.grid(row=7, column=0, columnspan=6, sticky=\"we\", pady=(0, 0), padx=(0, 0))\r\n        mode_row.columnconfigure(3, weight=1)  # let the group breathe\r\n\r\n        ttk.Radiobutton(mode_row, text=\"Jisho only\", variable=self.source_mode, value=0) \\\r\n            .grid(row=0, column=0, padx=8, pady=6, sticky=\"w\")\r\n        ttk.Radiobutton(mode_row, text=\"GPT only\", variable=self.source_mode, value=1) \\\r\n            .grid(row=0, column=1, padx=8, pady=6, sticky=\"w\")\r\n        ttk.Radiobutton(mode_row, text=\"Jisho → GPT\", variable=self.source_mode, value=2) \\\r\n            .grid(row=0, column=2, padx=8, pady=6, sticky=\"w\")\r\n\r\n        # single status label (put it AFTER the radios)\r\n        self.status = ttk.Label(top, text=\"Ready\")\r\n        self.status.grid(row=8, column=0, columnspan=6, sticky=\"w\", pady=(8, 0))\r\n\r\n        # Make the text area expandable\r\n        top.grid_columnconfigure(1, weight=1)\r\n        top.grid_rowconfigure(1, weight=1)\r\n\r\n        # --- Table preview ---\r\n        table_frame = ttk.Frame(self, padding=8)\r\n        table_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)\r\n\r\n        columns = (\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\")\r\n        self.tree = ttk.Treeview(table_frame, columns=columns, show=\"headings\", height=14)\r\n\r\n        # headings\r\n        for col in columns:\r\n            self.tree.heading(col, text=col)\r\n\r\n        # column widths + stretching\r\n        self.tree.column(\"Term\", width=150, anchor=\"w\", stretch=False)\r\n        self.tree.column(\"Reading\", width=140, anchor=\"w\", stretch=False)\r\n        self.tree.column(\"Meaning\", width=260, anchor=\"w\", stretch=True)\r\n        self.tree.column(\"Example\", width=360, anchor=\"w\", stretch=True)\r\n        self.tree.column(\"JLPT\", width=80, anchor=\"w\", stretch=False)\r\n\r\n        # zebra striping\r\n        self.tree.tag_configure(\"oddrow\", background=\"#f6f7fb\")  # light grey for readability\r\n\r\n        # layout with vertical scrollbar\r\n        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\r\n        scroll_y = ttk.Scrollbar(table_frame, orient=\"vertical\", command=self.tree.yview)\r\n        self.tree.configure(yscrollcommand=scroll_y.set)\r\n        scroll_y.pack(side=tk.RIGHT, fill=tk.Y)\r\n\r\n    # --- utilities ---\r\n    def _set_buttons_enabled(self, enabled: bool):\r\n        state = \"normal\" if enabled else \"disabled\"\r\n        for b in getattr(self, \"_buttons\", []):\r\n            try:\r\n                b.configure(state=state)\r\n            except Exception:\r\n                pass\r\n\r\n    # --- UI handlers ---\r\n    def browse_sa(self):\r\n        path = filedialog.askopenfilename(title=\"Select Service Account JSON\",\r\n                                          filetypes=[(\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")])\r\n        if path:\r\n            self.sa_entry.delete(0, tk.END)\r\n            self.sa_entry.insert(0, path)\r\n\r\n    def on_parse(self):\r\n        raw = self.text.get(\"1.0\", \"end-1c\")\r\n        self.rows = parse_blob(raw)\r\n        self.refresh_table()\r\n        self.status.config(text=f\"Parsed {len(self.rows)} rows.\")\r\n        if not self.rows:\r\n            messagebox.showwarning(\"No entries parsed\",\r\n                                   \"I couldn't find any entries. Format should look like: 語（ご） meanings ...\")\r\n\r\n    def refresh_table(self):\r\n        \"\"\"Clear and repopulate the table from self.rows\"\"\"\r\n        self.tree.delete(*self.tree.get_children())\r\n        for idx, r in enumerate(self.rows):\r\n            row5 = (r + [\"\", \"\", \"\", \"\", \"\"])[:5]  # Term, Reading, Meaning, Example, JLPT\r\n            tags = (\"oddrow\",) if (idx % 2) else ()\r\n            self.tree.insert(\"\", \"end\", values=row5, tags=tags)\r\n\r\n    def on_clear(self):\r\n        \"\"\"Clear the raw input and the parsed table.\"\"\"\r\n        # clear the Text input\r\n        self.text.delete(\"1.0\", \"end\")\r\n        # clear parsed rows + table\r\n        self.rows = []\r\n        self.tree.delete(*self.tree.get_children())\r\n        # update status + focus back to input\r\n        self.status.config(text=\"Cleared input and table.\")\r\n        try:\r\n            self.text.focus_set()\r\n        except Exception:\r\n            pass\r\n\r\n    def on_save_csv(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to save\", \"Parse first, then save.\")\r\n            return\r\n        path = filedialog.asksaveasfilename(\r\n            title=\"Save CSV\",\r\n            defaultextension=\".csv\",\r\n            filetypes=[(\"CSV\", \"*.csv\"), (\"All files\", \"*.*\")]\r\n        )\r\n        if not path:\r\n            return\r\n        try:\r\n            width = max(len(r) for r in self.rows) if self.rows else 3\r\n            headers = [\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\"] if width >= 5 else [\"Term\", \"Reading\", \"Meaning\"]\r\n            with open(path, \"w\", encoding=\"utf-8-sig\", newline=\"\") as f:\r\n                writer = csv.writer(f)\r\n                writer.writerow(headers)\r\n                for r in self.rows:\r\n                    row = (r + [\"\", \"\", \"\"])[:len(headers)]\r\n                    writer.writerow(row)\r\n            self.status.config(text=f\"Saved CSV: {path}\")\r\n        except Exception as e:\r\n            messagebox.showerror(\"Save error\", str(e))\r\n\r\n    def on_read_sheet(self):\r\n        sa = self.sa_entry.get().strip()\r\n        sheet_id = self.sheet_entry.get().strip()\r\n        tab = self.tab_entry.get().strip()\r\n        if not (sa and sheet_id and tab):\r\n            messagebox.showwarning(\"Missing details\",\r\n                                   \"Please provide Service Account JSON path, Sheet ID, and Tab name.\")\r\n            return\r\n        try:\r\n            svc = get_service(sa)\r\n            self.rows = read_from_sheet(svc, sheet_id, tab)\r\n            self.refresh_table()\r\n            self.status.config(text=f\"Read {len(self.rows)} rows from {tab}.\")\r\n            messagebox.showinfo(\"Done\", f\"Read {len(self.rows)} rows from '{tab}'.\")\r\n        except HttpError as he:\r\n            messagebox.showerror(\"Google API error\", str(he))\r\n        except Exception as e:\r\n            messagebox.showerror(\"Error\", str(e))\r\n\r\n    def on_write_sheet(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to write\", \"Parse first, then write to Google Sheet.\")\r\n            return\r\n        sa = self.sa_entry.get().strip()\r\n        sheet_id = self.sheet_entry.get().strip()\r\n        tab = self.tab_entry.get().strip()\r\n        backup_tab = self.backup_tab_entry.get().strip()\r\n        do_backup = self.backup_var.get()\r\n        if not (sa and sheet_id and tab):\r\n            messagebox.showwarning(\"Missing details\",\r\n                                   \"Please provide Service Account JSON path, Sheet ID, and Tab name.\")\r\n            return\r\n        try:\r\n            svc = get_service(sa)\r\n            if do_backup:\r\n                raw = self.text.get(\"1.0\", \"end-1c\").strip()\r\n                if raw:\r\n                    backup_raw(svc, sheet_id, backup_tab, raw)\r\n            write_to_sheet(svc, sheet_id, tab, self.rows, write_headers=True, clear_body=True)\r\n            self.status.config(text=f\"Wrote {len(self.rows)} rows to {tab} in the Google Sheet.\")\r\n            messagebox.showinfo(\"Done\", f\"Wrote {len(self.rows)} rows to '{tab}'.\")\r\n        except HttpError as he:\r\n            messagebox.showerror(\"Google API error\", str(he))\r\n        except Exception as e:\r\n            messagebox.showerror(\"Error\", str(e))\r\n\r\n    def get_openai_client() -> OpenAI:\r\n        \"\"\"Lazy-load the OpenAI client (env var OPENAI_API_KEY or fallback file).\"\"\"\r\n        global _client\r\n        if _client is None:\r\n            api_key = os.getenv(\"OPENAI_API_KEY\")\r\n            if not api_key:\r\n                key_file = Path(__file__).resolve().parent / \".venv\" / \"Lib\" / \"gpt_api_secret.txt\"\r\n                api_key = key_file.read_text(encoding=\"utf-8\").strip()\r\n            _client = OpenAI(api_key=api_key)\r\n        return _client\r\n\r\n    def generate_example_with_gpt(term: str) -> str:\r\n        \"\"\"Return a short Japanese example sentence using the supplied term.\"\"\"\r\n        client = get_openai_client()\r\n        prompt = (\r\n            f\"Output ONLY one short natural Japanese example sentence using the word '{term}'. \"\r\n            \"Do not include translations, explanations, or any other text.\"\r\n        )\r\n        resp = client.chat.completions.create(\r\n            model=\"gpt-5-nano\",\r\n            messages=[{\"role\": \"user\", \"content\": prompt}],\r\n            max_tokens=60,\r\n            temperature=0.7,\r\n        )\r\n        # ✅ current SDK uses attribute access\r\n        # safer: handle SDK object and possible missing content\r\n        msg = resp.choices[0].message\r\n        text = getattr(msg, \"content\", \"\") or \"\"\r\n        return text.strip()\r\n\r\n    # ------------- Parsing logic -------------\r\n    TERM_BLOCK_RE = re.compile(r'([^\\s（]+)（([^）]+)）\\s+(.+?)(?=\\s+[^\\s（]+（[^）]+）|\\s*$)')\r\n\r\n    FURIGANA_RE = re.compile(r\"\\([^)]*\\)\")\r\n\r\n    def remove_furigana(text: str) -> str:\r\n        return FURIGANA_RE.sub(\"\", text)\r\n\r\n    def top_two_non_wiki_meanings(w_data) -> str:\r\n        picked = []\r\n        for sense in w_data.senses:\r\n            if \"Wikipedia definition\" in (sense.parts_of_speech or []):\r\n                continue\r\n            if sense.english_definitions:\r\n                picked.append(\", \".join(sense.english_definitions))\r\n            if len(picked) >= 2:\r\n                break\r\n        return \"; \".join(picked[:2]) if picked else \"\"\r\n\r\n    def fetch_example_sentence(term: str) -> str:\r\n        try:\r\n            s_res = Sentence.request(term)\r\n            if s_res.data:\r\n                return remove_furigana(s_res.data[0].japanese)\r\n        except Exception:\r\n            pass\r\n        return \"\"\r\n\r\n    def augment_row_with_jisho(term: str, reading_hint: str | None) -> list[str]:\r\n        \"\"\"\r\n        Returns: [Term, Reading, Meaning(2 max, non-Wikipedia), Example, JLPT]\r\n        \"\"\"\r\n        w_res = Word.request(term)\r\n        if not w_res.data and reading_hint:\r\n            w_res = Word.request(reading_hint)\r\n        if not w_res.data:\r\n            return [term, reading_hint or \"\", \"\", \"\", \"\"]\r\n\r\n        w = w_res.data[0]\r\n        jp0 = w.japanese[0]\r\n        out_term = jp0.word or jp0.reading or term\r\n        out_reading = jp0.reading or (reading_hint or \"\")\r\n        meanings = top_two_non_wiki_meanings(w)\r\n        example = fetch_example_sentence(term)\r\n        jlpt = \", \".join(w.jlpt) if w.jlpt else \"\"\r\n\r\n        return [out_term, out_reading, meanings or \"\", example, jlpt]\r\n\r\n    def split_meanings(s: str):\r\n        \"\"\"Split on commas not inside ASCII parentheses; keep semicolons as-is.\"\"\"\r\n        parts, current, depth = [], [], 0\r\n        for ch in s:\r\n            if ch == '(':\r\n                depth += 1\r\n            elif ch == ')' and depth > 0:\r\n                depth -= 1\r\n            if ch == ',' and depth == 0:\r\n                part = ''.join(current).strip()\r\n                if part:\r\n                    parts.append(part)\r\n                current = []\r\n            else:\r\n                current.append(ch)\r\n        last = ''.join(current).strip()\r\n        if last:\r\n            parts.append(last)\r\n        return parts\r\n\r\n    def parse_blob(text: str):\r\n        \"\"\"\r\n        Return list of [Term, Reading, Meaning, Example, JLPT].\r\n        Example and JLPT are empty strings at parse time; the Jisho augment fills them later.\r\n        \"\"\"\r\n        text = re.sub(r\"\\s+\", \" \", text.strip())\r\n        rows = []\r\n        for m in TERM_BLOCK_RE.finditer(text):\r\n            term = m.group(1).strip()\r\n            reading = m.group(2).strip()\r\n            meanings_raw = m.group(3).strip()\r\n            meanings = \", \".join(split_meanings(meanings_raw))\r\n            rows.append([term, reading, meanings, \"\", \"\"])  # <-- pad Example, JLPT\r\n        return rows\r\n\r\n    # ------------- Google Sheets helpers -------------\r\n    SCOPES = [\"https://www.googleapis.com/auth/spreadsheets\"]\r\n\r\n    def get_service(sa_json_path: str):\r\n        creds = service_account.Credentials.from_service_account_file(sa_json_path, scopes=SCOPES)\r\n        return build(\"sheets\", \"v4\", credentials=creds)\r\n\r\n    def ensure_sheet_exists(service, spreadsheet_id: str, title: str):\r\n        meta = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()\r\n        if any(s.get(\"properties\", {}).get(\"title\") == title for s in meta.get(\"sheets\", [])):\r\n            return\r\n        service.spreadsheets().batchUpdate(\r\n            spreadsheetId=spreadsheet_id,\r\n            body={\"requests\": [{\"addSheet\": {\"properties\": {\"title\": title}}}]},\r\n        ).execute()\r\n\r\n    def write_to_sheet(service, sheet_id: str, tab: str, rows: list,\r\n                       write_headers=True, clear_body=True):\r\n        \"\"\"Write headers and rows; adapts to 3 or 5 columns based on data.\"\"\"\r\n        values_api = service.spreadsheets().values()\r\n        width = max(len(r) for r in rows) if rows else 3\r\n        if width >= 5:\r\n            headers = [\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\"]\r\n            header_range = f\"{tab}!A1:E1\"\r\n            clear_range = f\"{tab}!A2:E\"\r\n            write_start = f\"{tab}!A2\"\r\n        else:\r\n            headers = [\"Term\", \"Reading\", \"Meaning\"]\r\n            header_range = f\"{tab}!A1:C1\"\r\n            clear_range = f\"{tab}!A2:C\"\r\n            write_start = f\"{tab}!A2\"\r\n\r\n        if write_headers:\r\n            values_api.update(\r\n                spreadsheetId=sheet_id,\r\n                range=header_range,\r\n                valueInputOption=\"USER_ENTERED\",\r\n                body={\"values\": [headers]},\r\n            ).execute()\r\n        if clear_body:\r\n            values_api.clear(spreadsheetId=sheet_id, range=clear_range).execute()\r\n        if rows:\r\n            # pad each row to width\r\n            padded = [(r + [\"\", \"\", \"\"])[:len(headers)] for r in rows]\r\n            values_api.update(\r\n                spreadsheetId=sheet_id,\r\n                range=write_start,\r\n                valueInputOption=\"USER_ENTERED\",\r\n                body={\"values\": padded},\r\n            ).execute()\r\n\r\n    def read_from_sheet(service, sheet_id: str, tab: str) -> list:\r\n        \"\"\"Read Term/Reading/Meaning rows (columns A:D) from a sheet.\"\"\"\r\n        values = service.spreadsheets().values().get(\r\n            spreadsheetId=sheet_id,\r\n            range=f\"{tab}!A:E\",\r\n        ).execute().get(\"values\", [])\r\n        rows = []\r\n        for r in values[1:]:  # drop header row\r\n            padded = (r + [\"\", \"\", \"\"])[:5]\r\n            if any(c.strip() for c in padded):\r\n                rows.append(padded)\r\n        return rows\r\n\r\n    def backup_raw(service, sheet_id: str, backup_tab: str, raw_text: str):\r\n        ensure_sheet_exists(service, sheet_id, backup_tab)\r\n        ts = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        service.spreadsheets().values().append(\r\n            spreadsheetId=sheet_id,\r\n            range=f\"{backup_tab}!A:B\",\r\n            valueInputOption=\"RAW\",\r\n            insertDataOption=\"INSERT_ROWS\",\r\n            body={\"values\": [[ts, raw_text]]},\r\n        ).execute()\r\n\r\n    # ------------- Anki helpers -------------\r\n    def stable_id(name: str) -> int:\r\n        \"\"\"Deterministic 32-bit int from a name (for deck/model IDs).\"\"\"\r\n        return int(hashlib.sha1(name.encode(\"utf-8\")).hexdigest()[:8], 16)\r\n\r\n    def make_anki_deck(rows: list, deck_name: str):\r\n        \"\"\"\r\n        Build a genanki.Deck from rows = [[Term, Reading, Meaning, Example, JLPT], ...].\r\n        Uses a model with 6 fields: Term, Reading, Meaning, Example, JLPT, Date.\r\n        \"\"\"\r\n        deck_id = stable_id(deck_name)\r\n        model_name = \"JP Vocab Basic v3\"\r\n        model_id = stable_id(model_name)\r\n\r\n        model = genanki.Model(\r\n            model_id=model_id,\r\n            name=model_name,\r\n            fields=[\r\n                {\"name\": \"Term\"},\r\n                {\"name\": \"Reading\"},\r\n                {\"name\": \"Meaning\"},\r\n                {\"name\": \"Example\"},\r\n                {\"name\": \"JLPT\"},\r\n                {\"name\": \"Date\"},\r\n            ],\r\n            templates=[\r\n                {\r\n                    \"name\": \"Card 1\",\r\n                    \"qfmt\": \"\"\"\r\n    <div style=\"display:flex;align-items:center;justify-content:center;min-height:65vh;font-size:60px;font-weight:700;\">\r\n      {{Term}}\r\n    </div>\r\n                    \"\"\",\r\n                    \"afmt\": \"\"\"\r\n    <div style=\"display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:65vh;padding:10px;color:#fff !important;\">\r\n      <div style=\"font-size:60px;font-weight:700;\">{{Term}}</div>\r\n      <div style=\"font-size:34px;margin-top:10px;\">{{Reading}}</div>\r\n      <hr style=\"width:100%;border:none;border-top:1px solid #aaa;margin:16px 0;\">\r\n      <div style=\"font-size:28px;line-height:1.4;text-align:center;max-width:900px;\">\r\n        {{Meaning}}\r\n      </div>\r\n      {{#Example}}\r\n      <div style=\"margin-top:16px;font-size:24px;line-height:1.4;text-align:center;max-width:900px;\">\r\n        <b>Example:</b> {{Example}}\r\n      </div>\r\n      {{/Example}}\r\n      {{#JLPT}}\r\n      <div style=\"margin-top:12px;font-size:18px;color:#ddd;\">\r\n        JLPT: {{JLPT}}\r\n      </div>\r\n      {{/JLPT}}\r\n      <div style=\"font-size:14px;color:#eaeaea;margin-top:16px;\">\r\n        Added: {{Date}}\r\n      </div>\r\n    </div>\r\n    \"\"\"\r\n                }\r\n            ],\r\n        )\r\n\r\n        deck = genanki.Deck(deck_id=deck_id, name=deck_name)\r\n        today = datetime.today().strftime(\"%Y-%m-%d\")\r\n\r\n        for row in rows:\r\n            # pad to 5 fields if needed\r\n            term, reading, meaning, example, jlpt = (row + [\"\", \"\", \"\"])[:5]\r\n            guid = genanki.guid_for(f\"v3|{term}|{reading}\")  # version tag to avoid collision\r\n            note = genanki.Note(\r\n                model=model,\r\n                fields=[term, reading, meaning, example, jlpt, today],\r\n                guid=guid,\r\n            )\r\n            deck.add_note(note)\r\n\r\n        return deck\r\n\r\n    # ------------- GUI -------------\r\n    class App(tk.Tk):\r\n        def __init__(self):\r\n            super().__init__()\r\n            self.title(\"Japanese Vocab Parser → CSV / Google Sheets / Anki\")\r\n            self.geometry(\"1000x680\")\r\n\r\n            controls_frame = ttk.Frame(self)\r\n            controls_frame.pack(fill=\"x\", padx=10, pady=6)\r\n\r\n            # 1) Create the service once and reuse\r\n            self.topic_service = TopicGeneratorService(augment_row_with_jisho=augment_row_with_jisho)\r\n\r\n            # Pick best-available theming\r\n            if tb:\r\n                tb.Style(\"darkly\")  # nice light theme; try \"darkly\" for dark\r\n            elif sv_ttk:\r\n                sv_ttk.set_theme(\"dark\")\r\n            else:\r\n                ttk.Style().theme_use(\"clam\")\r\n\r\n            # in App.__init__(), after creating the root\r\n            self.option_add(\"*Font\", (\"Segoe UI\", 10))\r\n            style = ttk.Style()\r\n            style.configure(\"TButton\", padding=(10, 6))\r\n            style.configure(\"TRadiobutton\", padding=(6, 2))\r\n            style.configure(\"TCheckbutton\", padding=(6, 2))\r\n            style.configure(\"Treeview.Heading\", font=(\"Segoe UI Semibold\", 10))\r\n            style.configure(\"Treeview\", rowheight=26)\r\n\r\n            # 2) Add minimal UI controls\r\n            self.topic_var = tk.StringVar()\r\n            self.topic_count_var = tk.IntVar(value=30)\r\n            self.gpt_only_var = tk.BooleanVar(value=False)\r\n\r\n            ttk.Label(controls_frame, text=\"Topic:\").grid(row=0, column=0, padx=4, pady=4, sticky=\"w\")\r\n            ttk.Entry(controls_frame, textvariable=self.topic_var, width=24).grid(row=0, column=1, padx=4, pady=4,\r\n                                                                                  sticky=\"we\")\r\n            ttk.Label(controls_frame, text=\"Items:\").grid(row=0, column=2, padx=4, pady=4, sticky=\"e\")\r\n            ttk.Spinbox(controls_frame, from_=5, to=200, textvariable=self.topic_count_var, width=6).grid(row=0,\r\n                                                                                                          column=3,\r\n                                                                                                          padx=4,\r\n                                                                                                          pady=4)\r\n            ttk.Checkbutton(controls_frame, text=\"GPT only\", variable=self.gpt_only_var).grid(row=0, column=4, padx=6)\r\n            ttk.Button(controls_frame, text=\"Generate from Topic\", command=self.on_generate_from_topic).grid(row=0,\r\n                                                                                                             column=5,\r\n                                                                                                             padx=6)\r\n            self.append_var = tk.BooleanVar(value=True)  # default: append\r\n            ttk.Checkbutton(controls_frame, text=\"Append\", variable=self.append_var).grid(row=0, column=6, padx=6)\r\n\r\n            # State\r\n            self.rows = []\r\n            self.only_fill_empty_var = tk.BooleanVar(value=True)\r\n\r\n            # Top frame: inputs + buttons\r\n            top = ttk.Frame(self, padding=8)\r\n            top.pack(side=tk.TOP, fill=tk.X)\r\n\r\n            # Raw input\r\n            ttk.Label(top, text=\"Paste raw vocab text:\").grid(row=0, column=0, sticky=\"w\")\r\n            self.text = tk.Text(top, height=8, wrap=\"word\")\r\n            self.text.grid(row=1, column=0, columnspan=6, sticky=\"nsew\", pady=(4, 8))\r\n            text_scroll = ttk.Scrollbar(top, orient=\"vertical\", command=self.text.yview)\r\n            text_scroll.grid(row=1, column=6, sticky=\"ns\")\r\n            self.text.configure(yscrollcommand=text_scroll.set)\r\n\r\n            # Google config\r\n            ttk.Label(top, text=\"Service Account JSON:\").grid(row=2, column=0, sticky=\"w\", pady=(2, 0))\r\n            self.sa_entry = ttk.Entry(top, width=60)\r\n            self.sa_entry.grid(row=2, column=1, columnspan=4, sticky=\"we\", padx=(4, 4))\r\n\r\n            # ✅ Insert your default path\r\n            default_sa_path = r\"C:/Users/Tom/OneDrive/Coding Projects/Japanese_App_BackUp_Words/.venv/Scripts/python-fs-automation-3181504752ca.json\"\r\n            self.sa_entry.insert(0, default_sa_path)\r\n\r\n            ttk.Button(top, text=\"Browse…\", command=self.browse_sa).grid(row=2, column=5, sticky=\"w\")\r\n\r\n            ttk.Label(top, text=\"Sheet ID:\").grid(row=3, column=0, sticky=\"w\", pady=(2, 0))\r\n            self.sheet_entry = ttk.Entry(top, width=60)\r\n            self.sheet_entry.grid(row=3, column=1, columnspan=4, sticky=\"we\", padx=(4, 4))\r\n\r\n            ttk.Label(top, text=\"Tab name:\").grid(row=4, column=0, sticky=\"w\", pady=(2, 0))\r\n            self.tab_entry = ttk.Entry(top, width=20)\r\n            self.tab_entry.insert(0, \"List_Test_Data\")\r\n            self.tab_entry.grid(row=4, column=1, sticky=\"w\")\r\n\r\n            ttk.Label(top, text=\"Backup tab:\").grid(row=4, column=2, sticky=\"e\")\r\n            self.backup_tab_entry = ttk.Entry(top, width=20)\r\n            self.backup_tab_entry.insert(0, \"Raw_Backup\")\r\n            self.backup_tab_entry.grid(row=4, column=3, sticky=\"w\", padx=(4, 4))\r\n            self.backup_var = tk.BooleanVar(value=True)\r\n            ttk.Checkbutton(top, text=\"Backup raw input\", variable=self.backup_var).grid(row=4, column=4, sticky=\"w\")\r\n\r\n            # Toggle\r\n            ttk.Checkbutton(top, text=\"Only fill empty Example\",\r\n                            variable=self.only_fill_empty_var).grid(row=4, column=5, sticky=\"w\")\r\n\r\n            # Buttons\r\n            btns = ttk.Frame(top)\r\n            btns.grid(row=5, column=0, columnspan=6, sticky=\"w\", pady=(10, 4))\r\n            self._buttons = []\r\n            style.configure(\"Tool.TButton\", padding=(12, 6))\r\n\r\n            def _add_btn(text, cmd):\r\n                b = ttk.Button(btns, text=text, command=cmd, style=\"Tool.TButton\")\r\n                b.pack(side=tk.LEFT, padx=6)\r\n\r\n            _add_btn(\"Parse\uD83E\uDDFE\", self.on_parse)\r\n            _add_btn(\"Save CSV\uD83D\uDCBE\", self.on_save_csv)\r\n            _add_btn(\"Read from Google Sheet⬇\uFE0F\", self.on_read_sheet)\r\n            _add_btn(\"Write to Google Sheet⬆\uFE0F\", self.on_write_sheet)\r\n            _add_btn(\"Make Anki Deck\uD83C\uDCCF\", self.on_make_anki)\r\n            _add_btn(\"Augment Examples✨\", self.on_augment_examples)\r\n\r\n            # --- Source mode controls ---\r\n            self.source_mode = tk.IntVar(value=2)  # 0=Jisho only, 1=GPT only, 2=Jisho→GPT\r\n\r\n            # one separator to divide toolbar and options\r\n            ttk.Separator(top, orient=\"horizontal\").grid(row=6, column=0, columnspan=6, sticky=\"we\", pady=(8, 8))\r\n\r\n            # labelled group FOR radios (single instance)\r\n            mode_row = ttk.LabelFrame(top, text=\"Example source\")\r\n            mode_row.grid(row=7, column=0, columnspan=6, sticky=\"we\", pady=(0, 0), padx=(0, 0))\r\n            mode_row.columnconfigure(3, weight=1)  # let the group breathe\r\n\r\n            ttk.Radiobutton(mode_row, text=\"Jisho only\", variable=self.source_mode, value=0) \\\r\n                .grid(row=0, column=0, padx=8, pady=6, sticky=\"w\")\r\n            ttk.Radiobutton(mode_row, text=\"GPT only\", variable=self.source_mode, value=1) \\\r\n                .grid(row=0, column=1, padx=8, pady=6, sticky=\"w\")\r\n            ttk.Radiobutton(mode_row, text=\"Jisho → GPT\", variable=self.source_mode, value=2) \\\r\n                .grid(row=0, column=2, padx=8, pady=6, sticky=\"w\")\r\n\r\n            # single status label (put it AFTER the radios)\r\n            self.status = ttk.Label(top, text=\"Ready\")\r\n            self.status.grid(row=8, column=0, columnspan=6, sticky=\"w\", pady=(8, 0))\r\n\r\n            # Make the text area expandable\r\n            top.grid_columnconfigure(1, weight=1)\r\n            top.grid_rowconfigure(1, weight=1)\r\n\r\n            # --- Table preview ---\r\n            table_frame = ttk.Frame(self, padding=8)\r\n            table_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)\r\n\r\n            columns = (\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\")\r\n            self.tree = ttk.Treeview(table_frame, columns=columns, show=\"headings\", height=14)\r\n\r\n            # headings\r\n            for col in columns:\r\n                self.tree.heading(col, text=col)\r\n\r\n            # column widths + stretching\r\n            self.tree.column(\"Term\", width=150, anchor=\"w\", stretch=False)\r\n            self.tree.column(\"Reading\", width=140, anchor=\"w\", stretch=False)\r\n            self.tree.column(\"Meaning\", width=260, anchor=\"w\", stretch=True)\r\n            self.tree.column(\"Example\", width=360, anchor=\"w\", stretch=True)\r\n            self.tree.column(\"JLPT\", width=80, anchor=\"w\", stretch=False)\r\n\r\n            # # zebra striping\r\n            # self.tree.tag_configure(\"oddrow\", background=\"#f6f7fb\")  # light grey for readability\r\n\r\n            # layout with vertical scrollbar\r\n            self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\r\n            scroll_y = ttk.Scrollbar(table_frame, orient=\"vertical\", command=self.tree.yview)\r\n            self.tree.configure(yscrollcommand=scroll_y.set)\r\n            scroll_y.pack(side=tk.RIGHT, fill=tk.Y)\r\n\r\n        # --- utilities ---\r\n        def _set_buttons_enabled(self, enabled: bool):\r\n            state = \"normal\" if enabled else \"disabled\"\r\n            for b in getattr(self, \"_buttons\", []):\r\n                try:\r\n                    b.configure(state=state)\r\n                except Exception:\r\n                    pass\r\n\r\n        # --- UI handlers ---\r\n        def browse_sa(self):\r\n            path = filedialog.askopenfilename(title=\"Select Service Account JSON\",\r\n                                              filetypes=[(\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")])\r\n            if path:\r\n                self.sa_entry.delete(0, tk.END)\r\n                self.sa_entry.insert(0, path)\r\n\r\n        def on_parse(self):\r\n            raw = self.text.get(\"1.0\", \"end-1c\")\r\n            self.rows = parse_blob(raw)\r\n            self.refresh_table()\r\n            self.status.config(text=f\"Parsed {len(self.rows)} rows.\")\r\n            if not self.rows:\r\n                messagebox.showwarning(\"No entries parsed\",\r\n                                       \"I couldn't find any entries. Format should look like: 語（ご） meanings ...\")\r\n\r\n        def refresh_table(self):\r\n            \"\"\"Clear and repopulate the table from self.rows\"\"\"\r\n            self.tree.delete(*self.tree.get_children())\r\n            for r in self.rows:\r\n                # ensure exactly 4 values (pad if needed)\r\n                row4 = (r + [\"\", \"\", \"\", \"\"])[:4]\r\n                self.tree.insert(\"\", \"end\", values=row4)\r\n\r\n        def on_save_csv(self):\r\n            if not self.rows:\r\n                messagebox.showinfo(\"Nothing to save\", \"Parse first, then save.\")\r\n                return\r\n            path = filedialog.asksaveasfilename(\r\n                title=\"Save CSV\",\r\n                defaultextension=\".csv\",\r\n                filetypes=[(\"CSV\", \"*.csv\"), (\"All files\", \"*.*\")]\r\n            )\r\n            if not path:\r\n                return\r\n            try:\r\n                width = max(len(r) for r in self.rows) if self.rows else 3\r\n                headers = [\"Term\", \"Reading\", \"Meaning\", \"Example\", \"JLPT\"] if width >= 5 else [\"Term\", \"Reading\",\r\n                                                                                                \"Meaning\"]\r\n                with open(path, \"w\", encoding=\"utf-8-sig\", newline=\"\") as f:\r\n                    writer = csv.writer(f)\r\n                    writer.writerow(headers)\r\n                    for r in self.rows:\r\n                        row = (r + [\"\", \"\", \"\"])[:len(headers)]\r\n                        writer.writerow(row)\r\n                self.status.config(text=f\"Saved CSV: {path}\")\r\n            except Exception as e:\r\n                messagebox.showerror(\"Save error\", str(e))\r\n\r\n        def on_read_sheet(self):\r\n            sa = self.sa_entry.get().strip()\r\n            sheet_id = self.sheet_entry.get().strip()\r\n            tab = self.tab_entry.get().strip()\r\n            if not (sa and sheet_id and tab):\r\n                messagebox.showwarning(\"Missing details\",\r\n                                       \"Please provide Service Account JSON path, Sheet ID, and Tab name.\")\r\n                return\r\n            try:\r\n                svc = get_service(sa)\r\n                self.rows = read_from_sheet(svc, sheet_id, tab)\r\n                self.refresh_table()\r\n                self.status.config(text=f\"Read {len(self.rows)} rows from {tab}.\")\r\n                messagebox.showinfo(\"Done\", f\"Read {len(self.rows)} rows from '{tab}'.\")\r\n            except HttpError as he:\r\n                messagebox.showerror(\"Google API error\", str(he))\r\n            except Exception as e:\r\n                messagebox.showerror(\"Error\", str(e))\r\n\r\n        def on_write_sheet(self):\r\n            if not self.rows:\r\n                messagebox.showinfo(\"Nothing to write\", \"Parse first, then write to Google Sheet.\")\r\n                return\r\n            sa = self.sa_entry.get().strip()\r\n            sheet_id = self.sheet_entry.get().strip()\r\n            tab = self.tab_entry.get().strip()\r\n            backup_tab = self.backup_tab_entry.get().strip()\r\n            do_backup = self.backup_var.get()\r\n            if not (sa and sheet_id and tab):\r\n                messagebox.showwarning(\"Missing details\",\r\n                                       \"Please provide Service Account JSON path, Sheet ID, and Tab name.\")\r\n                return\r\n            try:\r\n                svc = get_service(sa)\r\n                if do_backup:\r\n                    raw = self.text.get(\"1.0\", \"end-1c\").strip()\r\n                    if raw:\r\n                        backup_raw(svc, sheet_id, backup_tab, raw)\r\n                write_to_sheet(svc, sheet_id, tab, self.rows, write_headers=True, clear_body=True)\r\n                self.status.config(text=f\"Wrote {len(self.rows)} rows to {tab} in the Google Sheet.\")\r\n                messagebox.showinfo(\"Done\", f\"Wrote {len(self.rows)} rows to '{tab}'.\")\r\n            except HttpError as he:\r\n                messagebox.showerror(\"Google API error\", str(he))\r\n            except Exception as e:\r\n                messagebox.showerror(\"Error\", str(e))\r\n\r\n        def on_augment_examples(self):\r\n            if not self.rows:\r\n                messagebox.showinfo(\"Nothing to augment\", \"Parse or load rows first, then choose a source mode.\")\r\n                return\r\n\r\n            mode = int(self.source_mode.get())  # 0=Jisho only, 1=GPT only, 2=Jisho→GPT\r\n            self._set_buttons_enabled(False)\r\n            self.status.config(text=\"Starting augmentation…\")\r\n            threading.Thread(target=self._enrich_worker, args=(mode,), daemon=True).start()\r\n\r\n        def _enrich_worker(self, mode: int):\r\n            \"\"\"Run Jisho + GPT enrichment over self.rows.\"\"\"\r\n\r\n            def ensure_width5(row):\r\n                row = list(row)\r\n                if len(row) < 5:\r\n                    row.extend([\"\"] * (5 - len(row)))\r\n                return row\r\n\r\n            def has_text(s: str | None) -> bool:\r\n                return bool((s or \"\").strip())\r\n\r\n            try:\r\n                # Jisho and GPT enrichment passes...\r\n                # (use the code we wrote earlier here)\r\n                pass\r\n            finally:\r\n                self.after(0, self.refresh_table)\r\n                self.after(0, self.status.config, {\"text\": \"Augmentation complete.\"})\r\n                self.after(0, self._set_buttons_enabled, True)\r\n                self.after(0, messagebox.showinfo, \"Done\", \"Examples augmented per selected mode.\")\r\n\r\n        # -----Self-Service Generator-----#\r\n\r\n        # put this helper anywhere inside App\r\n        def _pulse(self, text: str):\r\n            # update UI + console so you can see progress even if a thread stalls\r\n            try:\r\n                self.after(0, self.status.config, {\"text\": text})\r\n            except Exception:\r\n                pass\r\n            print(text, flush=True)\r\n\r\n        # REPLACE your on_generate_from_topic with this version\r\n        def on_generate_from_topic(self):\r\n            topic = (self.topic_var.get() or \"\").strip()\r\n            if not topic:\r\n                messagebox.showinfo(\"Topic required\", \"Type a topic (e.g., 空港 / airport).\")\r\n                return\r\n\r\n            count = max(5, int(self.topic_count_var.get() or 30))\r\n            gpt_only = bool(self.gpt_only_var.get())\r\n\r\n            # disable UI\r\n            self._set_buttons_enabled(False)\r\n            self.status.config(text=f\"Generating {count} unique items for: {topic} …\")\r\n\r\n            def run():\r\n                try:\r\n                    # Build the avoid set from current table (Term, Reading)\r\n                    existing_keys = set()\r\n                    for r in (self.rows or []):\r\n                        term = (r[0] if len(r) > 0 else \"\").strip()\r\n                        reading = (r[1] if len(r) > 1 else \"\").strip()\r\n                        if term:\r\n                            existing_keys.add((term, reading))\r\n\r\n                    target = count\r\n                    new_rows: list[list[str]] = []\r\n                    # batch size: big enough to make progress, small enough for quick UI pulses\r\n                    batch_size = max(10, min(50, target * 2))\r\n                    rounds = 0\r\n                    no_progress_rounds = 0\r\n                    MAX_ROUNDS = 30  # safety\r\n\r\n                    while len(new_rows) < target:\r\n                        rounds += 1\r\n                        needed = target - len(new_rows)\r\n                        ask_for = max(needed, batch_size)\r\n\r\n                        self._pulse(f\"[{rounds}] Requesting ~{ask_for} items (need {needed} more)…\")\r\n\r\n                        # IMPORTANT: we pass existing_keys so the service avoids known items\r\n                        # If your TopicGeneratorService does NOT accept existing_keys, remove it here.\r\n                        batch = self.topic_service.generate_rows(\r\n                            topic=topic,\r\n                            count=ask_for,\r\n                            gpt_only=gpt_only,\r\n                            existing_keys=existing_keys  # <-- service should respect this\r\n                        )\r\n\r\n                        kept_before = len(new_rows)\r\n\r\n                        # De-dup against existing table and what we've already collected this run\r\n                        for row in (batch or []):\r\n                            term = (row[0] if len(row) > 0 else \"\").strip()\r\n                            reading = (row[1] if len(row) > 1 else \"\").strip()\r\n                            if not term:\r\n                                continue\r\n                            key = (term, reading)\r\n                            if key in existing_keys:\r\n                                continue\r\n                            # also dedupe within this run\r\n                            if any(((r[0] if len(r) > 0 else \"\").strip(), (r[1] if len(r) > 1 else \"\").strip()) == key\r\n                                   for r in new_rows):\r\n                                continue\r\n\r\n                            new_rows.append(row)\r\n                            existing_keys.add(key)  # avoid in future rounds\r\n                            if len(new_rows) >= target:\r\n                                break\r\n\r\n                        kept_now = len(new_rows)\r\n                        gained = kept_now - kept_before\r\n                        self._pulse(\r\n                            f\"[{rounds}] Got {len(batch)} from service; kept {gained}; total {kept_now}/{target}\")\r\n\r\n                        if gained == 0:\r\n                            no_progress_rounds += 1\r\n                        else:\r\n                            no_progress_rounds = 0\r\n\r\n                        # safety valves to prevent real hangs\r\n                        if no_progress_rounds >= 5:\r\n                            raise RuntimeError(\"No progress after several rounds. The generator may be stuck.\")\r\n                        if rounds >= MAX_ROUNDS:\r\n                            raise RuntimeError(\"Too many rounds while trying to reach requested count.\")\r\n\r\n                    # Merge into table (append or replace)\r\n                    if self.append_var.get():\r\n                        try:\r\n                            merged, added, updated, *_ = merge_rows(self.rows or [], new_rows)\r\n                        except ValueError:\r\n                            merged, added, updated = merge_rows(self.rows or [], new_rows)\r\n                        self.rows = merged\r\n                        msg = f\"Appended {added} new, updated {updated}. Total: {len(self.rows)}\"\r\n                    else:\r\n                        self.rows = new_rows\r\n                        msg = f\"Replaced with {len(new_rows)} rows.\"\r\n\r\n                    # refresh UI\r\n                    self.after(0, self.refresh_table)\r\n                    self._pulse(msg)\r\n\r\n                    # optional: kick off enrichment\r\n                    self.after(0, self.start_enrichment_worker)\r\n\r\n                except Exception as e:\r\n                    self.after(0, messagebox.showerror, \"Topic generation failed\", str(e))\r\n                    self._pulse(\"Topic generation failed.\")\r\n                finally:\r\n                    self.after(0, self._set_buttons_enabled, True)\r\n\r\n            threading.Thread(target=run, daemon=True).start()\r\n\r\n        def start_enrichment_worker(self):\r\n            try:\r\n                mode_value = int(self.source_mode.get())\r\n            except Exception:\r\n                mode_value = 2\r\n            self.status.config(text=\"Starting enrichment…\")\r\n            threading.Thread(target=self._enrich_worker, args=(mode_value,), daemon=True).start()\r\n\r\n        def _generate_topic_worker(self, topic, n, gpt_only):\r\n            try:\r\n                rows = self.topic_service.generate_rows(topic, count=n, gpt_only=gpt_only)\r\n                self.rows = rows\r\n                self.refresh_table()\r\n                self.status.config(text=f\"Generated {len(rows)} items for “{topic}”.\")\r\n            except Exception as e:\r\n                messagebox.showerror(\"Topic generation failed\", str(e))\r\n                self.status.config(text=\"Topic generation failed.\")\r\n            finally:\r\n                self._set_controls_state(\"normal\")\r\n\r\n        def _set_controls_state(self, state: str):\r\n            # keep it simple; adjust to your layout\r\n            for child in self.winfo_children():\r\n                try:\r\n                    child.configure(state=state)\r\n                except:\r\n                    pass\r\n\r\n        def on_make_anki(self):\r\n            if not self.rows:\r\n                messagebox.showinfo(\"Nothing to export\", \"Parse first, then make an Anki deck.\")\r\n                return\r\n\r\n            default_name = f\"JP Vocab ({datetime.today().strftime('%Y-%m-%d')})\"\r\n            deck_name = simpledialog.askstring(\"Deck name\", \"Enter Anki deck name:\", initialvalue=default_name)\r\n            if not deck_name:\r\n                return\r\n\r\n            out_path = filedialog.asksaveasfilename(\r\n                title=\"Save Anki Deck\",\r\n                defaultextension=\".apkg\",\r\n                filetypes=[(\"Anki package\", \"*.apkg\"), (\"All files\", \"*.*\")]\r\n            )\r\n            if not out_path:\r\n                return\r\n\r\n            try:\r\n                deck = make_anki_deck(self.rows, deck_name)\r\n                genanki.Package(deck).write_to_file(out_path)\r\n                self.status.config(text=f\"Anki deck saved: {out_path}\")\r\n                messagebox.showinfo(\"Done\", f\"Anki deck saved:\\n{out_path}\")\r\n            except Exception as e:\r\n                messagebox.showerror(\"Anki export error\", str(e))\r\n\r\n    if __name__ == \"__main__\":\r\n        App().mainloop()\r\n\r\n    def on_augment_examples(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to augment\", \"Parse first, then choose a source mode.\")\r\n            return\r\n\r\n        mode = self.source_mode.get()  # 0 = Jisho only, 1 = GPT only, 2 = Jisho → GPT\r\n\r\n        def ensure_width5(row):\r\n            row = list(row)\r\n            if len(row) < 5:\r\n                row.extend([\"\"] * (5 - len(row)))\r\n            return row\r\n\r\n        def has_text(s: str | None) -> bool:\r\n            return bool((s or \"\").strip())\r\n\r\n        def worker(self, mode):\r\n            try:\r\n                n = len(self.rows)\r\n                jisho_updates = 0\r\n                gpt_updates = 0\r\n\r\n                # -------- PASS 1: Jisho (full enrichment) --------\r\n                if mode in (0, 2):\r\n                    for i, row in enumerate(self.rows):\r\n                        row = ensure_width5(row)\r\n                        term = (row[0] if row else \"\").strip()\r\n                        reading_hint = (row[1] if len(row) > 1 else \"\").strip() or None\r\n\r\n                        try:\r\n                            new_row = augment_row_with_jisho(term, reading_hint)\r\n                            new_row = ensure_width5(new_row)\r\n                        except Exception as e:\r\n                            print(f\"[JISHO ENRICH ERROR] {term!r}: {e}\")\r\n                            new_row = row  # keep old row on error\r\n\r\n                        # Respect \"Only fill empty Example\"\r\n                        if self.only_fill_empty_var.get() and has_text(row[3]) and not has_text(new_row[3]):\r\n                            new_row[3] = row[3]\r\n\r\n                        self.rows[i] = new_row\r\n                        jisho_updates += 1 if new_row != row else 0\r\n\r\n                        self.after(0, self.status.config, {\r\n                            \"text\": f\"Jisho enrichment… {i + 1}/{n} (updated: {jisho_updates})\"\r\n                        })\r\n\r\n                # -------- PASS 2: GPT (only where needed) --------\r\n                if mode in (1, 2):\r\n                    for i, row in enumerate(self.rows):\r\n                        row = ensure_width5(row)\r\n                        term = (row[0] if row else \"\").strip()\r\n\r\n                        # GPT-only: obey \"only fill empty\" if the checkbox is on\r\n                        if mode == 1 and self.only_fill_empty_var.get() and has_text(row[3]):\r\n                            continue\r\n\r\n                        # Jisho → GPT: only fill where Example is still empty\r\n                        need_gpt = (mode == 1) or (mode == 2 and not has_text(row[3]))\r\n                        if not need_gpt:\r\n                            continue\r\n\r\n                        try:\r\n                            ex = (generate_example_with_gpt(term) or \"\").strip()\r\n                        except Exception as e:\r\n                            print(f\"[GPT ERROR] {term!r}: {e}\")\r\n                            ex = \"\"\r\n\r\n                        if ex:\r\n                            row[3] = ex\r\n                            self.rows[i] = row\r\n                            gpt_updates += 1\r\n                            preview = (ex[:18] + \"…\") if len(ex) > 20 else ex\r\n                            self.after(0, self.status.config, {\r\n                                \"text\": f\"GPT pass… {gpt_updates} examples written — '{preview}'\"\r\n                            })\r\n\r\n                        time.sleep(0.25)  # be gentle\r\n\r\n            finally:\r\n                self.after(0, self.refresh_table)\r\n                self.after(0, self.status.config, {\"text\": \"Augmentation complete.\"})\r\n                self.after(0, self._set_buttons_enabled, True)\r\n                self.after(0, messagebox.showinfo, \"Done\", \"Examples augmented per selected mode.\")\r\n\r\n        self._set_buttons_enabled(False)\r\n        self.status.config(text=\"Starting augmentation…\")\r\n        threading.Thread(target=worker, daemon=True).start()\r\n\r\n    #-----Self-Service Generator-----#\r\n\r\n    def on_generate_from_topic(self):\r\n        topic = (self.topic_var.get() or \"\").strip()\r\n        if not topic:\r\n            messagebox.showinfo(\"Topic required\", \"Type a topic (e.g., 空港 / airport).\")\r\n            return\r\n\r\n        count = max(5, int(self.topic_count_var.get() or 30))\r\n        gpt_only = bool(self.gpt_only_var.get())\r\n\r\n        # UI: disable while working\r\n        self._set_buttons_enabled(False)\r\n        self.status.config(text=f\"Generating {count} items for: {topic} …\")\r\n\r\n        def run():\r\n            try:\r\n                # 1) Get new rows from the topic service\r\n                new_rows = self.topic_service.generate_rows(\r\n                    topic=topic, count=count, gpt_only=gpt_only\r\n                )\r\n\r\n                # 2) Merge or replace\r\n                if self.append_var.get():\r\n                    merged, added, updated, added_keys = merge_rows(self.rows or [], new_rows)\r\n                    self.rows = merged\r\n                    self._last_added_keys = added_keys  # optional: for Treeview highlighting\r\n                    msg = f\"Appended {added} new, updated {updated}. Total: {len(self.rows)}\"\r\n                else:\r\n                    self.rows = new_rows\r\n                    self._last_added_keys = set()\r\n                    msg = f\"Replaced with {len(new_rows)} rows.\"\r\n\r\n                # 3) Refresh table with merged/replaced data\r\n                self.after(0, self.refresh_table)\r\n                self.after(0, self.status.config, {\"text\": msg})\r\n\r\n                # 4) Kick off enrichment worker on the merged set\r\n                self.after(0, self.start_enrichment_worker)\r\n\r\n            except Exception as e:\r\n                self.after(0, messagebox.showerror, \"Topic generation failed\", str(e))\r\n                self.after(0, self.status.config, {\"text\": \"Topic generation failed.\"})\r\n            finally:\r\n                self.after(0, self._set_buttons_enabled, True)\r\n\r\n        threading.Thread(target=run, daemon=True).start()\r\n\r\n    def start_enrichment_worker(self):\r\n        \"\"\"\r\n        Starts your existing enrichment worker over self.rows (merged list).\r\n        Assumes you have something like self.only_fill_empty_var and a 'mode' selector.\r\n        mode: 0=Jisho only, 1=GPT only, 2=Both (based on your earlier code).\r\n        \"\"\"\r\n        try:\r\n            mode = getattr(self, \"enrich_mode_var\", None)\r\n            mode_value = int(mode.get()) if mode is not None else 2  # default both\r\n        except Exception:\r\n            mode_value = 2\r\n\r\n        self.status.config(text=\"Starting enrichment…\")\r\n        threading.Thread(target=lambda: self.worker(mode_value), daemon=True).start()\r\n\r\n\r\n    def _generate_topic_worker(self, topic, n, gpt_only):\r\n        try:\r\n            rows = self.topic_service.generate_rows(topic, count=n, gpt_only=gpt_only)\r\n            self.rows = rows\r\n            self.refresh_table()\r\n            self.status.config(text=f\"Generated {len(rows)} items for “{topic}”.\")\r\n        except Exception as e:\r\n            messagebox.showerror(\"Topic generation failed\", str(e))\r\n            self.status.config(text=\"Topic generation failed.\")\r\n        finally:\r\n            self._set_controls_state(\"normal\")\r\n\r\n    def _set_controls_state(self, state: str):\r\n        # keep it simple; adjust to your layout\r\n        for child in self.winfo_children():\r\n            try: child.configure(state=state)\r\n            except: pass\r\n\r\n    def on_make_anki(self):\r\n        if not self.rows:\r\n            messagebox.showinfo(\"Nothing to export\", \"Parse first, then make an Anki deck.\")\r\n            return\r\n\r\n        default_name = f\"JP Vocab ({datetime.today().strftime('%Y-%m-%d')})\"\r\n        deck_name = simpledialog.askstring(\"Deck name\", \"Enter Anki deck name:\", initialvalue=default_name)\r\n        if not deck_name:\r\n            return\r\n\r\n        out_path = filedialog.asksaveasfilename(\r\n            title=\"Save Anki Deck\",\r\n            defaultextension=\".apkg\",\r\n            filetypes=[(\"Anki package\", \"*.apkg\"), (\"All files\", \"*.*\")]\r\n        )\r\n        if not out_path:\r\n            return\r\n\r\n        try:\r\n            deck = make_anki_deck(self.rows, deck_name)\r\n            genanki.Package(deck).write_to_file(out_path)\r\n            self.status.config(text=f\"Anki deck saved: {out_path}\")\r\n            messagebox.showinfo(\"Done\", f\"Anki deck saved:\\n{out_path}\")\r\n        except Exception as e:\r\n            messagebox.showerror(\"Anki export error\", str(e))\r\n\r\nif __name__ == \"__main__\":\r\n    App().mainloop()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Scen2.1.Clean_Augment_Japanese_App_List_Data.py b/Scen2.1.Clean_Augment_Japanese_App_List_Data.py
--- a/Scen2.1.Clean_Augment_Japanese_App_List_Data.py	(revision 9bc9320c1a83230db43a4ef43e60991a50bb6734)
+++ b/Scen2.1.Clean_Augment_Japanese_App_List_Data.py	(date 1761995950573)
@@ -43,7 +43,7 @@
     if _client is None:
         api_key = os.getenv("OPENAI_API_KEY")
         if not api_key:
-            key_file = Path(__file__).resolve().parent / ".venv" / "Lib" / "gpt_api_secret.txt"
+            key_file = Path(__file__).resolve().parent / ".venv" / "Lib" / "OPENAI_API_KEY.txt"
             api_key = key_file.read_text(encoding="utf-8").strip()
         _client = OpenAI(api_key=api_key)
     return _client
@@ -596,7 +596,7 @@
         if _client is None:
             api_key = os.getenv("OPENAI_API_KEY")
             if not api_key:
-                key_file = Path(__file__).resolve().parent / ".venv" / "Lib" / "gpt_api_secret.txt"
+                key_file = Path(__file__).resolve().parent / ".venv" / "Lib" / "OPENAI_API_KEY.txt"
                 api_key = key_file.read_text(encoding="utf-8").strip()
             _client = OpenAI(api_key=api_key)
         return _client
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"f489c1f1-bc78-44b9-918c-5d775ad9a5d8\" name=\"Changes\" comment=\"Augmented and working\">\r\n      <change afterPath=\"$PROJECT_DIR$/From_English_Translate.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/extractor.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Scen2.1.Clean_Augment_Japanese_App_List_Data.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Scen2.1.Clean_Augment_Japanese_App_List_Data.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/topic_service.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/topic_service.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"3164Y3LEitrxjgeKBcFKFIbzdFX\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.Call_Jisho_API.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.Jisho_API_Most_Common.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.Scen1.1.Clean_Japanese_App_List_Data.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.Scen2.1.Clean_Augment_Japanese_App_List_Data.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/Tom/OneDrive/Coding Projects/clean_Japanese_Custom_Vocab_List_and_Anki_Creator&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;terminal&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\Tom\\OneDrive\\Coding Projects\\clean_Japanese_Custom_Vocab_List_and_Anki_Creator\" />\r\n      <recent name=\"C:\\Users\\Tom\\OneDrive\\Coding Projects\\clean_Japanese_Custom_Vocab_List_and_Anki_Creator\\.venv\\Lib\" />\r\n      <recent name=\"C:\\Users\\Tom\\OneDrive\\Coding Projects\\clean_Japanese_Custom_Vocab_List_and_Anki_Creator\\.venv\\Scripts\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data\">\r\n    <configuration name=\"Call_Jisho_API\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"clean_Japanese_Custom_Vocab_List_and_Anki_Creator\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Call_Jisho_API.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Jisho_API_Most_Common\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"clean_Japanese_Custom_Vocab_List_and_Anki_Creator\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Jisho_API_Most_Common.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"Scen2.1.Clean_Augment_Japanese_App_List_Data\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"clean_Japanese_Custom_Vocab_List_and_Anki_Creator\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n        <env name=\"OPENAI_API_KEY\" value=\"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\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Scen2.1.Clean_Augment_Japanese_App_List_Data.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"v2Scen2.1.Clean_Augment_Japanese_App_List_Data\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"clean_Japanese_Custom_Vocab_List_and_Anki_Creator\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n        <env name=\"OPENAI_API_KEY\" value=\"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\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/v2Scen2.1.Clean_Augment_Japanese_App_List_Data.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data\" />\r\n      <item itemvalue=\"Python.Call_Jisho_API\" />\r\n      <item itemvalue=\"Python.Jisho_API_Most_Common\" />\r\n      <item itemvalue=\"Python.Scen2.1.Clean_Augment_Japanese_App_List_Data\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data\" />\r\n        <item itemvalue=\"Python.Scen2.1.Clean_Augment_Japanese_App_List_Data\" />\r\n        <item itemvalue=\"Python.Jisho_API_Most_Common\" />\r\n        <item itemvalue=\"Python.Call_Jisho_API\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-0509580d9d50-746f403e7f0c-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-241.14494.241\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"f489c1f1-bc78-44b9-918c-5d775ad9a5d8\" name=\"Changes\" comment=\"\" />\r\n      <created>1754831232478</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1754831232478</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"First commit\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1754831653510</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1754831653510</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"First commit\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1754831934477</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1754831934478</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"After venv change\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1754833626304</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1754833626304</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Augmented and working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1754837578608</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1754837578609</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Augmented and working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1755331336939</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1755331336939</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"Augmented and working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1755347472986</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1755347472986</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"Augmented and working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1755370862864</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1755370862864</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Augmented and working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1755389665646</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1755389665646</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Augmented and working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1755391192800</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1755391192800</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"Augmented and working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1756020811771</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1756020811771</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"11\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"RECENT_FILTERS\">\r\n      <map>\r\n        <entry key=\"Branch\">\r\n          <value>\r\n            <list>\r\n              <RecentGroup>\r\n                <option name=\"FILTER_VALUES\">\r\n                  <option value=\"main\" />\r\n                </option>\r\n              </RecentGroup>\r\n            </list>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"main\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"First commit\" />\r\n    <MESSAGE value=\"After venv change\" />\r\n    <MESSAGE value=\"Augmented and working\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Augmented and working\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 9bc9320c1a83230db43a4ef43e60991a50bb6734)
+++ b/.idea/workspace.xml	(date 1761997171912)
@@ -4,9 +4,7 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="f489c1f1-bc78-44b9-918c-5d775ad9a5d8" name="Changes" comment="Augmented and working">
-      <change afterPath="$PROJECT_DIR$/From_English_Translate.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/extractor.py" afterDir="false" />
+    <list default="true" id="f489c1f1-bc78-44b9-918c-5d775ad9a5d8" name="Changes" comment="Everything is working: 250824.1458">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Scen2.1.Clean_Augment_Japanese_App_List_Data.py" beforeDir="false" afterPath="$PROJECT_DIR$/Scen2.1.Clean_Augment_Japanese_App_List_Data.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/topic_service.py" beforeDir="false" afterPath="$PROJECT_DIR$/topic_service.py" afterDir="false" />
@@ -36,19 +34,21 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;Python.Call_Jisho_API.executor&quot;: &quot;Run&quot;,
-    &quot;Python.Jisho_API_Most_Common.executor&quot;: &quot;Run&quot;,
-    &quot;Python.Scen1.1.Clean_Japanese_App_List_Data.executor&quot;: &quot;Run&quot;,
-    &quot;Python.Scen2.1.Clean_Augment_Japanese_App_List_Data.executor&quot;: &quot;Run&quot;,
-    &quot;Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data.executor&quot;: &quot;Run&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
-    &quot;last_opened_file_path&quot;: &quot;C:/Users/Tom/OneDrive/Coding Projects/clean_Japanese_Custom_Vocab_List_and_Anki_Creator&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;terminal&quot;
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Python.Call_Jisho_API.executor": "Run",
+    "Python.Jisho_API_Most_Common.executor": "Run",
+    "Python.Scen1.1.Clean_Japanese_App_List_Data.executor": "Run",
+    "Python.Scen2.1.Clean_Augment_Japanese_App_List_Data.executor": "Run",
+    "Python.TestOpenAIAPI.executor": "Run",
+    "Python.temp_html_to_pdf.executor": "Run",
+    "Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data.executor": "Run",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "git-widget-placeholder": "main",
+    "last_opened_file_path": "C:/Users/Tom/OneDrive/Coding Projects/clean_Japanese_Custom_Vocab_List_and_Anki_Creator",
+    "settings.editor.selected.configurable": "terminal"
   }
-}</component>
+}]]></component>
   <component name="RecentsManager">
     <key name="CopyFile.RECENT_KEYS">
       <recent name="C:\Users\Tom\OneDrive\Coding Projects\clean_Japanese_Custom_Vocab_List_and_Anki_Creator" />
@@ -57,7 +57,7 @@
     </key>
   </component>
   <component name="RunManager" selected="Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data">
-    <configuration name="Call_Jisho_API" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="Jisho_API_Most_Common" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="clean_Japanese_Custom_Vocab_List_and_Anki_Creator" />
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -70,7 +70,7 @@
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Call_Jisho_API.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Jisho_API_Most_Common.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -79,20 +79,21 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="Jisho_API_Most_Common" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="Scen2.1.Clean_Augment_Japanese_App_List_Data" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="clean_Japanese_Custom_Vocab_List_and_Anki_Creator" />
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
       <envs>
         <env name="PYTHONUNBUFFERED" value="1" />
+        <env name="OPENAI_API_KEY" value="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" />
       </envs>
       <option name="SDK_HOME" value="" />
       <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Jisho_API_Most_Common.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Scen2.1.Clean_Augment_Japanese_App_List_Data.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -101,21 +102,20 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="Scen2.1.Clean_Augment_Japanese_App_List_Data" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="TestOpenAIAPI" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="clean_Japanese_Custom_Vocab_List_and_Anki_Creator" />
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
       <envs>
         <env name="PYTHONUNBUFFERED" value="1" />
-        <env name="OPENAI_API_KEY" value="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" />
       </envs>
       <option name="SDK_HOME" value="" />
       <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Scen2.1.Clean_Augment_Japanese_App_List_Data.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/TestOpenAIAPI.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -124,15 +124,33 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="v2Scen2.1.Clean_Augment_Japanese_App_List_Data" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="temp_html_to_pdf" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="clean_Japanese_Custom_Vocab_List_and_Anki_Creator" />
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
       <envs>
         <env name="PYTHONUNBUFFERED" value="1" />
-        <env name="OPENAI_API_KEY" value="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" />
       </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/temp_html_to_pdf.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
+    <configuration name="v2Scen2.1.Clean_Augment_Japanese_App_List_Data" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="clean_Japanese_Custom_Vocab_List_and_Anki_Creator" />
+      <option name="ENV_FILES" value="" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
       <option name="SDK_HOME" value="" />
       <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
       <option name="IS_MODULE_SDK" value="true" />
@@ -148,17 +166,19 @@
       <method v="2" />
     </configuration>
     <list>
-      <item itemvalue="Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data" />
-      <item itemvalue="Python.Call_Jisho_API" />
+      <item itemvalue="Python.TestOpenAIAPI" />
       <item itemvalue="Python.Jisho_API_Most_Common" />
       <item itemvalue="Python.Scen2.1.Clean_Augment_Japanese_App_List_Data" />
+      <item itemvalue="Python.temp_html_to_pdf" />
+      <item itemvalue="Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data" />
     </list>
     <recent_temporary>
       <list>
         <item itemvalue="Python.v2Scen2.1.Clean_Augment_Japanese_App_List_Data" />
+        <item itemvalue="Python.TestOpenAIAPI" />
         <item itemvalue="Python.Scen2.1.Clean_Augment_Japanese_App_List_Data" />
+        <item itemvalue="Python.temp_html_to_pdf" />
         <item itemvalue="Python.Jisho_API_Most_Common" />
-        <item itemvalue="Python.Call_Jisho_API" />
       </list>
     </recent_temporary>
   </component>
@@ -258,7 +278,15 @@
       <option name="project" value="LOCAL" />
       <updated>1756020811771</updated>
     </task>
-    <option name="localTasksCounter" value="11" />
+    <task id="LOCAL-00011" summary="Everything is working: 250824.1458">
+      <option name="closed" value="true" />
+      <created>1756043894090</created>
+      <option name="number" value="00011" />
+      <option name="presentableId" value="LOCAL-00011" />
+      <option name="project" value="LOCAL" />
+      <updated>1756043894090</updated>
+    </task>
+    <option name="localTasksCounter" value="12" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -303,6 +331,7 @@
     <MESSAGE value="First commit" />
     <MESSAGE value="After venv change" />
     <MESSAGE value="Augmented and working" />
-    <option name="LAST_COMMIT_MESSAGE" value="Augmented and working" />
+    <MESSAGE value="Everything is working: 250824.1458" />
+    <option name="LAST_COMMIT_MESSAGE" value="Everything is working: 250824.1458" />
   </component>
 </project>
\ No newline at end of file
